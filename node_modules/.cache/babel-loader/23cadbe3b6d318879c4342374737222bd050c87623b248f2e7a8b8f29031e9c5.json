{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { useEffect, useMemo, useRef } from 'react';\nimport { useQuery, useQueryClient } from '@tanstack/react-query';\nimport { useDataProvider } from './useDataProvider';\nimport { useEvent } from '../util';\nvar MAX_DATA_LENGTH_TO_CACHE = 100;\n/**\n * Call the dataProvider.getList() method and return the resolved result\n * as well as the loading state.\n *\n * The return value updates according to the request state:\n *\n * - start: { isPending: true, refetch }\n * - success: { data: [data from store], total: [total from response], isPending: false, refetch }\n * - error: { error: [error from response], isPending: false, refetch }\n *\n * This hook will return the cached result when called a second time\n * with the same parameters, until the response arrives.\n *\n * @param {string} resource The resource name, e.g. 'posts'\n * @param {Params} params The getList parameters { pagination, sort, filter, meta }\n * @param {Object} options Options object to pass to the queryClient.\n * May include side effects to be executed upon success or failure, e.g. { onSuccess: () => { refresh(); } }\n *\n * @typedef Params\n * @prop params.pagination The request pagination { page, perPage }, e.g. { page: 1, perPage: 10 }\n * @prop params.sort The request sort { field, order }, e.g. { field: 'id', order: 'DESC' }\n * @prop params.filter The request filters, e.g. { title: 'hello, world' }\n * @prop params.meta Optional meta parameters\n *\n * @returns The current request state. Destructure as { data, total, error, isPending, refetch }.\n *\n * @example\n *\n * import { useGetList } from 'react-admin';\n *\n * const LatestNews = () => {\n *     const { data, total, isPending, error } = useGetList(\n *         'posts',\n *         { pagination: { page: 1, perPage: 10 }, sort: { field: 'published_at', order: 'DESC' } }\n *     );\n *     if (isPending) { return <Loading />; }\n *     if (error) { return <p>ERROR</p>; }\n *     return <ul>{data.map(item =>\n *         <li key={item.id}>{item.title}</li>\n *     )}</ul>;\n * };\n */\nexport var useGetList = function (resource, params, options) {\n  if (params === void 0) {\n    params = {};\n  }\n  if (options === void 0) {\n    options = {};\n  }\n  var _a = params.pagination,\n    pagination = _a === void 0 ? {\n      page: 1,\n      perPage: 25\n    } : _a,\n    _b = params.sort,\n    sort = _b === void 0 ? {\n      field: 'id',\n      order: 'DESC'\n    } : _b,\n    _c = params.filter,\n    filter = _c === void 0 ? {} : _c,\n    meta = params.meta;\n  var dataProvider = useDataProvider();\n  var queryClient = useQueryClient();\n  var _d = options.onError,\n    onError = _d === void 0 ? noop : _d,\n    _e = options.onSuccess,\n    onSuccess = _e === void 0 ? noop : _e,\n    _f = options.onSettled,\n    onSettled = _f === void 0 ? noop : _f,\n    queryOptions = __rest(options, [\"onError\", \"onSuccess\", \"onSettled\"]);\n  var onSuccessEvent = useEvent(onSuccess);\n  var onErrorEvent = useEvent(onError);\n  var onSettledEvent = useEvent(onSettled);\n  var result = useQuery(__assign({\n    queryKey: [resource, 'getList', {\n      pagination: pagination,\n      sort: sort,\n      filter: filter,\n      meta: meta\n    }],\n    queryFn: function (queryParams) {\n      return dataProvider.getList(resource, {\n        pagination: pagination,\n        sort: sort,\n        filter: filter,\n        meta: meta,\n        signal: dataProvider.supportAbortSignal === true ? queryParams.signal : undefined\n      }).then(function (_a) {\n        var data = _a.data,\n          total = _a.total,\n          pageInfo = _a.pageInfo;\n        return {\n          data: data,\n          total: total,\n          pageInfo: pageInfo\n        };\n      });\n    }\n  }, queryOptions));\n  var metaValue = useRef(meta);\n  var resourceValue = useRef(resource);\n  useEffect(function () {\n    metaValue.current = meta;\n  }, [meta]);\n  useEffect(function () {\n    resourceValue.current = resource;\n  }, [resource]);\n  useEffect(function () {\n    var _a;\n    if (result.data === undefined || result.error != null || result.isFetching) return;\n    // optimistically populate the getOne cache\n    if (((_a = result.data) === null || _a === void 0 ? void 0 : _a.data) && result.data.data.length <= MAX_DATA_LENGTH_TO_CACHE) {\n      result.data.data.forEach(function (record) {\n        queryClient.setQueryData([resourceValue.current, 'getOne', {\n          id: String(record.id),\n          meta: metaValue.current\n        }], function (oldRecord) {\n          return oldRecord !== null && oldRecord !== void 0 ? oldRecord : record;\n        });\n      });\n    }\n    onSuccessEvent(result.data);\n  }, [onSuccessEvent, queryClient, result.data, result.error, result.isFetching]);\n  useEffect(function () {\n    if (result.error == null || result.isFetching) return;\n    onErrorEvent(result.error);\n  }, [onErrorEvent, result.error, result.isFetching]);\n  useEffect(function () {\n    if (result.status === 'pending' || result.isFetching) return;\n    onSettledEvent(result.data, result.error);\n  }, [onSettledEvent, result.data, result.error, result.status, result.isFetching]);\n  return useMemo(function () {\n    var _a, _b, _c;\n    return result.data ? __assign(__assign({}, result), {\n      data: (_a = result.data) === null || _a === void 0 ? void 0 : _a.data,\n      total: (_b = result.data) === null || _b === void 0 ? void 0 : _b.total,\n      pageInfo: (_c = result.data) === null || _c === void 0 ? void 0 : _c.pageInfo\n    }) : result;\n  }, [result]);\n};\nvar noop = function () {\n  return undefined;\n};","map":{"version":3,"names":["useEffect","useMemo","useRef","useQuery","useQueryClient","useDataProvider","useEvent","MAX_DATA_LENGTH_TO_CACHE","useGetList","resource","params","options","_a","pagination","page","perPage","_b","sort","field","order","_c","filter","meta","dataProvider","queryClient","_d","onError","noop","_e","onSuccess","_f","onSettled","queryOptions","__rest","onSuccessEvent","onErrorEvent","onSettledEvent","result","__assign","queryKey","queryFn","queryParams","getList","signal","supportAbortSignal","undefined","then","data","total","pageInfo","metaValue","resourceValue","current","error","isFetching","length","forEach","record","setQueryData","id","String","oldRecord","status"],"sources":["/Users/robertbinning/Documents/GitHub/robertbinning/passkey/node_modules/react-admin/node_modules/ra-core/src/dataProvider/useGetList.ts"],"sourcesContent":["import { useEffect, useMemo, useRef } from 'react';\nimport {\n    useQuery,\n    UseQueryOptions,\n    UseQueryResult,\n    useQueryClient,\n} from '@tanstack/react-query';\n\nimport { RaRecord, GetListParams, GetListResult } from '../types';\nimport { useDataProvider } from './useDataProvider';\nimport { useEvent } from '../util';\n\nconst MAX_DATA_LENGTH_TO_CACHE = 100;\n\n/**\n * Call the dataProvider.getList() method and return the resolved result\n * as well as the loading state.\n *\n * The return value updates according to the request state:\n *\n * - start: { isPending: true, refetch }\n * - success: { data: [data from store], total: [total from response], isPending: false, refetch }\n * - error: { error: [error from response], isPending: false, refetch }\n *\n * This hook will return the cached result when called a second time\n * with the same parameters, until the response arrives.\n *\n * @param {string} resource The resource name, e.g. 'posts'\n * @param {Params} params The getList parameters { pagination, sort, filter, meta }\n * @param {Object} options Options object to pass to the queryClient.\n * May include side effects to be executed upon success or failure, e.g. { onSuccess: () => { refresh(); } }\n *\n * @typedef Params\n * @prop params.pagination The request pagination { page, perPage }, e.g. { page: 1, perPage: 10 }\n * @prop params.sort The request sort { field, order }, e.g. { field: 'id', order: 'DESC' }\n * @prop params.filter The request filters, e.g. { title: 'hello, world' }\n * @prop params.meta Optional meta parameters\n *\n * @returns The current request state. Destructure as { data, total, error, isPending, refetch }.\n *\n * @example\n *\n * import { useGetList } from 'react-admin';\n *\n * const LatestNews = () => {\n *     const { data, total, isPending, error } = useGetList(\n *         'posts',\n *         { pagination: { page: 1, perPage: 10 }, sort: { field: 'published_at', order: 'DESC' } }\n *     );\n *     if (isPending) { return <Loading />; }\n *     if (error) { return <p>ERROR</p>; }\n *     return <ul>{data.map(item =>\n *         <li key={item.id}>{item.title}</li>\n *     )}</ul>;\n * };\n */\nexport const useGetList = <RecordType extends RaRecord = any>(\n    resource: string,\n    params: Partial<GetListParams> = {},\n    options: UseGetListOptions<RecordType> = {}\n): UseGetListHookValue<RecordType> => {\n    const {\n        pagination = { page: 1, perPage: 25 },\n        sort = { field: 'id', order: 'DESC' },\n        filter = {},\n        meta,\n    } = params;\n    const dataProvider = useDataProvider();\n    const queryClient = useQueryClient();\n    const {\n        onError = noop,\n        onSuccess = noop,\n        onSettled = noop,\n        ...queryOptions\n    } = options;\n    const onSuccessEvent = useEvent(onSuccess);\n    const onErrorEvent = useEvent(onError);\n    const onSettledEvent = useEvent(onSettled);\n\n    const result = useQuery<\n        GetListResult<RecordType>,\n        Error,\n        GetListResult<RecordType>\n    >({\n        queryKey: [resource, 'getList', { pagination, sort, filter, meta }],\n        queryFn: queryParams =>\n            dataProvider\n                .getList<RecordType>(resource, {\n                    pagination,\n                    sort,\n                    filter,\n                    meta,\n                    signal:\n                        dataProvider.supportAbortSignal === true\n                            ? queryParams.signal\n                            : undefined,\n                })\n                .then(({ data, total, pageInfo }) => ({\n                    data,\n                    total,\n                    pageInfo,\n                })),\n        ...queryOptions,\n    });\n\n    const metaValue = useRef(meta);\n    const resourceValue = useRef(resource);\n\n    useEffect(() => {\n        metaValue.current = meta;\n    }, [meta]);\n\n    useEffect(() => {\n        resourceValue.current = resource;\n    }, [resource]);\n\n    useEffect(() => {\n        if (\n            result.data === undefined ||\n            result.error != null ||\n            result.isFetching\n        )\n            return;\n\n        // optimistically populate the getOne cache\n        if (\n            result.data?.data &&\n            result.data.data.length <= MAX_DATA_LENGTH_TO_CACHE\n        ) {\n            result.data.data.forEach(record => {\n                queryClient.setQueryData(\n                    [\n                        resourceValue.current,\n                        'getOne',\n                        { id: String(record.id), meta: metaValue.current },\n                    ],\n                    oldRecord => oldRecord ?? record\n                );\n            });\n        }\n        onSuccessEvent(result.data);\n    }, [\n        onSuccessEvent,\n        queryClient,\n        result.data,\n        result.error,\n        result.isFetching,\n    ]);\n\n    useEffect(() => {\n        if (result.error == null || result.isFetching) return;\n        onErrorEvent(result.error);\n    }, [onErrorEvent, result.error, result.isFetching]);\n\n    useEffect(() => {\n        if (result.status === 'pending' || result.isFetching) return;\n        onSettledEvent(result.data, result.error);\n    }, [\n        onSettledEvent,\n        result.data,\n        result.error,\n        result.status,\n        result.isFetching,\n    ]);\n\n    return useMemo(\n        () =>\n            result.data\n                ? {\n                      ...result,\n                      data: result.data?.data,\n                      total: result.data?.total,\n                      pageInfo: result.data?.pageInfo,\n                  }\n                : result,\n        [result]\n    ) as UseQueryResult<RecordType[], Error> & {\n        total?: number;\n        pageInfo?: {\n            hasNextPage?: boolean;\n            hasPreviousPage?: boolean;\n        };\n    };\n};\n\nconst noop = () => undefined;\n\nexport type UseGetListOptions<RecordType extends RaRecord = any> = Omit<\n    UseQueryOptions<GetListResult<RecordType>, Error>,\n    'queryKey' | 'queryFn'\n> & {\n    onSuccess?: (value: GetListResult<RecordType>) => void;\n    onError?: (error: Error) => void;\n    onSettled?: (\n        data?: GetListResult<RecordType>,\n        error?: Error | null\n    ) => void;\n};\n\nexport type UseGetListHookValue<RecordType extends RaRecord = any> =\n    UseQueryResult<RecordType[], Error> & {\n        total?: number;\n        pageInfo?: {\n            hasNextPage?: boolean;\n            hasPreviousPage?: boolean;\n        };\n    };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}