{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { useEffect, useMemo } from 'react';\nimport { useQuery } from '@tanstack/react-query';\nimport useAuthProvider, { defaultAuthParams } from './useAuthProvider';\nimport useLogout from './useLogout';\nimport { removeDoubleSlashes, useBasename } from '../routing';\nimport { useNotify } from '../notification';\nimport { useEvent } from '../util';\nvar emptyParams = {};\n/**\n * Hook for getting the authentication status\n *\n * Calls the authProvider.checkAuth() method asynchronously.\n *\n * The return value updates according to the authProvider request state:\n *\n * - isPending: true just after mount, while the authProvider is being called. false once the authProvider has answered.\n * - authenticated: true while loading. then true or false depending on the authProvider response.\n *\n * To avoid rendering a component and force waiting for the authProvider response, use the useAuthState() hook\n * instead of the useAuthenticated() hook.\n *\n * You can render different content depending on the authenticated status.\n *\n * @see useAuthenticated()\n *\n * @param {Object} params Any params you want to pass to the authProvider\n *\n * @param {Boolean} logoutOnFailure: Optional. Whether the user should be logged out if the authProvider fails to authenticate them. False by default.\n *\n * @returns The current auth check state. Destructure as { authenticated, error, isPending }.\n *\n * @example\n * import { useAuthState, Loading } from 'react-admin';\n *\n * const MyPage = () => {\n *     const { isPending, authenticated } = useAuthState();\n *     if (isPending) {\n *         return <Loading />;\n *     }\n *     if (authenticated) {\n *        return <AuthenticatedContent />;\n *     }\n *     return <AnonymousContent />;\n * };\n */\nvar useAuthState = function (params, logoutOnFailure, queryOptions) {\n  if (params === void 0) {\n    params = emptyParams;\n  }\n  if (logoutOnFailure === void 0) {\n    logoutOnFailure = false;\n  }\n  if (queryOptions === void 0) {\n    queryOptions = emptyParams;\n  }\n  var authProvider = useAuthProvider();\n  var logout = useLogout();\n  var basename = useBasename();\n  var notify = useNotify();\n  var onSuccess = queryOptions.onSuccess,\n    onError = queryOptions.onError,\n    onSettled = queryOptions.onSettled,\n    options = __rest(queryOptions, [\"onSuccess\", \"onError\", \"onSettled\"]);\n  var result = useQuery(__assign({\n    queryKey: ['auth', 'checkAuth', params],\n    queryFn: function (_a) {\n      var signal = _a.signal;\n      // The authProvider is optional in react-admin\n      if (!authProvider) {\n        return true;\n      }\n      return authProvider.checkAuth(__assign(__assign({}, params), {\n        signal: signal\n      })).then(function () {\n        return true;\n      }).catch(function (error) {\n        // This is necessary because react-query requires the error to be defined\n        if (error != null) {\n          throw error;\n        }\n        throw new Error();\n      });\n    },\n    retry: false\n  }, options));\n  var onSuccessEvent = useEvent(onSuccess !== null && onSuccess !== void 0 ? onSuccess : noop);\n  var onSettledEvent = useEvent(onSettled !== null && onSettled !== void 0 ? onSettled : noop);\n  var onErrorEvent = useEvent(onError !== null && onError !== void 0 ? onError : function (error) {\n    var loginUrl = removeDoubleSlashes(\"\".concat(basename, \"/\").concat(defaultAuthParams.loginUrl));\n    if (logoutOnFailure) {\n      logout({}, error && error.redirectTo != null ? error.redirectTo : loginUrl);\n      var shouldSkipNotify = error && error.message === false;\n      !shouldSkipNotify && notify(getErrorMessage(error, 'ra.auth.auth_check_error'), {\n        type: 'error'\n      });\n    }\n  });\n  useEffect(function () {\n    if (result.data === undefined || result.isFetching) return;\n    onSuccessEvent(result.data);\n  }, [onSuccessEvent, result.data, result.isFetching]);\n  useEffect(function () {\n    if (result.error == null || result.isFetching) return;\n    onErrorEvent(result.error);\n  }, [onErrorEvent, result.error, result.isFetching]);\n  useEffect(function () {\n    if (result.status === 'pending' || result.isFetching) return;\n    onSettledEvent(result.data, result.error);\n  }, [onSettledEvent, result.data, result.error, result.status, result.isFetching]);\n  return useMemo(function () {\n    var _a;\n    return __assign(__assign({}, result), {\n      // If the data is undefined and the query isn't loading anymore, it means the query failed.\n      // In that case, we set authenticated to false unless there's no authProvider.\n      authenticated: ((_a = result.data) !== null && _a !== void 0 ? _a : result.isLoading) ? true : authProvider == null\n    });\n  }, [authProvider, result]);\n};\nexport default useAuthState;\nvar getErrorMessage = function (error, defaultMessage) {\n  return typeof error === 'string' ? error : typeof error === 'undefined' || !error.message ? defaultMessage : error.message;\n};\nvar noop = function () {};","map":{"version":3,"names":["useEffect","useMemo","useQuery","useAuthProvider","defaultAuthParams","useLogout","removeDoubleSlashes","useBasename","useNotify","useEvent","emptyParams","useAuthState","params","logoutOnFailure","queryOptions","authProvider","logout","basename","notify","onSuccess","onError","onSettled","options","__rest","result","__assign","queryKey","queryFn","_a","signal","checkAuth","then","catch","error","Error","retry","onSuccessEvent","noop","onSettledEvent","onErrorEvent","loginUrl","concat","redirectTo","shouldSkipNotify","message","getErrorMessage","type","data","undefined","isFetching","status","authenticated","isLoading","defaultMessage"],"sources":["/Users/robertbinning/Documents/GitHub/robertbinning/passkey/node_modules/react-admin/node_modules/ra-core/src/auth/useAuthState.ts"],"sourcesContent":["import { useEffect, useMemo } from 'react';\nimport {\n    QueryObserverResult,\n    useQuery,\n    UseQueryOptions,\n} from '@tanstack/react-query';\nimport useAuthProvider, { defaultAuthParams } from './useAuthProvider';\nimport useLogout from './useLogout';\nimport { removeDoubleSlashes, useBasename } from '../routing';\nimport { useNotify } from '../notification';\nimport { useEvent } from '../util';\n\nconst emptyParams = {};\n\n/**\n * Hook for getting the authentication status\n *\n * Calls the authProvider.checkAuth() method asynchronously.\n *\n * The return value updates according to the authProvider request state:\n *\n * - isPending: true just after mount, while the authProvider is being called. false once the authProvider has answered.\n * - authenticated: true while loading. then true or false depending on the authProvider response.\n *\n * To avoid rendering a component and force waiting for the authProvider response, use the useAuthState() hook\n * instead of the useAuthenticated() hook.\n *\n * You can render different content depending on the authenticated status.\n *\n * @see useAuthenticated()\n *\n * @param {Object} params Any params you want to pass to the authProvider\n *\n * @param {Boolean} logoutOnFailure: Optional. Whether the user should be logged out if the authProvider fails to authenticate them. False by default.\n *\n * @returns The current auth check state. Destructure as { authenticated, error, isPending }.\n *\n * @example\n * import { useAuthState, Loading } from 'react-admin';\n *\n * const MyPage = () => {\n *     const { isPending, authenticated } = useAuthState();\n *     if (isPending) {\n *         return <Loading />;\n *     }\n *     if (authenticated) {\n *        return <AuthenticatedContent />;\n *     }\n *     return <AnonymousContent />;\n * };\n */\nconst useAuthState = <ErrorType = Error>(\n    params: any = emptyParams,\n    logoutOnFailure: boolean = false,\n    queryOptions: UseAuthStateOptions<ErrorType> = emptyParams\n): UseAuthStateResult<ErrorType> => {\n    const authProvider = useAuthProvider();\n    const logout = useLogout();\n    const basename = useBasename();\n    const notify = useNotify();\n    const { onSuccess, onError, onSettled, ...options } = queryOptions;\n\n    const result = useQuery<boolean, any>({\n        queryKey: ['auth', 'checkAuth', params],\n        queryFn: ({ signal }) => {\n            // The authProvider is optional in react-admin\n            if (!authProvider) {\n                return true;\n            }\n            return authProvider\n                .checkAuth({ ...params, signal })\n                .then(() => true)\n                .catch(error => {\n                    // This is necessary because react-query requires the error to be defined\n                    if (error != null) {\n                        throw error;\n                    }\n\n                    throw new Error();\n                });\n        },\n        retry: false,\n        ...options,\n    });\n\n    const onSuccessEvent = useEvent(onSuccess ?? noop);\n    const onSettledEvent = useEvent(onSettled ?? noop);\n    const onErrorEvent = useEvent(\n        onError ??\n            ((error: any) => {\n                const loginUrl = removeDoubleSlashes(\n                    `${basename}/${defaultAuthParams.loginUrl}`\n                );\n                if (logoutOnFailure) {\n                    logout(\n                        {},\n                        error && error.redirectTo != null\n                            ? error.redirectTo\n                            : loginUrl\n                    );\n                    const shouldSkipNotify = error && error.message === false;\n                    !shouldSkipNotify &&\n                        notify(\n                            getErrorMessage(error, 'ra.auth.auth_check_error'),\n                            { type: 'error' }\n                        );\n                }\n            })\n    );\n\n    useEffect(() => {\n        if (result.data === undefined || result.isFetching) return;\n        onSuccessEvent(result.data);\n    }, [onSuccessEvent, result.data, result.isFetching]);\n\n    useEffect(() => {\n        if (result.error == null || result.isFetching) return;\n        onErrorEvent(result.error);\n    }, [onErrorEvent, result.error, result.isFetching]);\n\n    useEffect(() => {\n        if (result.status === 'pending' || result.isFetching) return;\n        onSettledEvent(result.data, result.error);\n    }, [\n        onSettledEvent,\n        result.data,\n        result.error,\n        result.status,\n        result.isFetching,\n    ]);\n\n    return useMemo(() => {\n        return {\n            ...result,\n            // If the data is undefined and the query isn't loading anymore, it means the query failed.\n            // In that case, we set authenticated to false unless there's no authProvider.\n            authenticated:\n                result.data ?? result.isLoading ? true : authProvider == null, // Optimistic,\n        };\n    }, [authProvider, result]);\n};\n\ntype UseAuthStateOptions<ErrorType = Error> = Omit<\n    UseQueryOptions<boolean, ErrorType>,\n    'queryKey' | 'queryFn'\n> & {\n    onSuccess?: (data: boolean) => void;\n    onError?: (err: ErrorType) => void;\n    onSettled?: (data?: boolean, error?: Error) => void;\n};\n\nexport type UseAuthStateResult<ErrorType = Error> = QueryObserverResult<\n    boolean,\n    ErrorType\n> & {\n    authenticated: boolean;\n};\n\nexport default useAuthState;\n\nconst getErrorMessage = (error, defaultMessage) =>\n    typeof error === 'string'\n        ? error\n        : typeof error === 'undefined' || !error.message\n          ? defaultMessage\n          : error.message;\n\nconst noop = () => {};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}