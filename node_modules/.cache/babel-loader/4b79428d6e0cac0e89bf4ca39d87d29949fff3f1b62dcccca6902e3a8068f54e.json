{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { useEffect, useMemo } from 'react';\nimport { useQuery, useQueryClient } from '@tanstack/react-query';\nimport { useDataProvider } from './useDataProvider';\nimport { useEvent } from '../util';\n/**\n * Call the dataProvider.getManyReference() method and return the resolved result\n * as well as the loading state.\n *\n * The return value updates according to the request state:\n *\n * - start: { isPending: true, refetch }\n * - success: { data: [data from store], total: [total from response], isPending: false, refetch }\n * - error: { error: [error from response], isPending: false, refetch }\n *\n * This hook will return the cached result when called a second time\n * with the same parameters, until the response arrives.\n *\n * @param {string} resource The resource name, e.g. 'posts'\n * @param {Params} params The getManyReference parameters { target, id, pagination, sort, filter, meta }\n * @param {Object} options Options object to pass to the queryClient.\n * May include side effects to be executed upon success or failure, e.g. { onSuccess: () => { refresh(); } }\n *\n * @typedef Params\n * @prop params.target The target resource key, e.g. 'post_id'\n * @prop params.id The identifier of the record to look for in target, e.g. '123'\n * @prop params.pagination The request pagination { page, perPage }, e.g. { page: 1, perPage: 10 }\n * @prop params.sort The request sort { field, order }, e.g. { field: 'id', order: 'DESC' }\n * @prop params.filter The request filters, e.g. { title: 'hello, world' }\n * @prop params.meta Optional meta parameters\n *\n * @returns The current request state. Destructure as { data, total, error, isPending, refetch }.\n *\n * @example\n *\n * import { useGetManyReference, useRecordContext } from 'react-admin';\n *\n * const PostComments = () => {\n *     const record = useRecordContext();\n *     // fetch all comments related to the current record\n *     const { data, isPending, error } = useGetManyReference(\n *         'comments',\n *         { target: 'post_id', id: record.id, pagination: { page: 1, perPage: 10 }, sort: { field: 'published_at', order: 'DESC' } }\n *     );\n *     if (isPending) { return <Loading />; }\n *     if (error) { return <p>ERROR</p>; }\n *     return <ul>{data.map(comment =>\n *         <li key={comment.id}>{comment.body}</li>\n *     )}</ul>;\n * };\n */\nexport var useGetManyReference = function (resource, params, options) {\n  if (params === void 0) {\n    params = {};\n  }\n  if (options === void 0) {\n    options = {};\n  }\n  var target = params.target,\n    id = params.id,\n    _a = params.pagination,\n    pagination = _a === void 0 ? {\n      page: 1,\n      perPage: 25\n    } : _a,\n    _b = params.sort,\n    sort = _b === void 0 ? {\n      field: 'id',\n      order: 'DESC'\n    } : _b,\n    _c = params.filter,\n    filter = _c === void 0 ? {} : _c,\n    meta = params.meta;\n  var dataProvider = useDataProvider();\n  var queryClient = useQueryClient();\n  var _d = options.onError,\n    onError = _d === void 0 ? noop : _d,\n    _e = options.onSuccess,\n    onSuccess = _e === void 0 ? noop : _e,\n    _f = options.onSettled,\n    onSettled = _f === void 0 ? noop : _f,\n    queryOptions = __rest(options, [\"onError\", \"onSuccess\", \"onSettled\"]);\n  var onSuccessEvent = useEvent(onSuccess);\n  var onErrorEvent = useEvent(onError);\n  var onSettledEvent = useEvent(onSettled);\n  var result = useQuery(__assign({\n    queryKey: [resource, 'getManyReference', {\n      target: target,\n      id: id,\n      pagination: pagination,\n      sort: sort,\n      filter: filter,\n      meta: meta\n    }],\n    queryFn: function (queryParams) {\n      if (!target || id == null) {\n        // check at runtime to support partial parameters with the enabled option\n        return Promise.reject(new Error('target and id are required'));\n      }\n      return dataProvider.getManyReference(resource, {\n        target: target,\n        id: id,\n        pagination: pagination,\n        sort: sort,\n        filter: filter,\n        meta: meta,\n        signal: dataProvider.supportAbortSignal === true ? queryParams.signal : undefined\n      }).then(function (_a) {\n        var data = _a.data,\n          total = _a.total,\n          pageInfo = _a.pageInfo;\n        return {\n          data: data,\n          total: total,\n          pageInfo: pageInfo\n        };\n      });\n    }\n  }, queryOptions));\n  useEffect(function () {\n    var _a, _b;\n    if (result.data === undefined) return;\n    // optimistically populate the getOne cache\n    (_b = (_a = result.data) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.forEach(function (record) {\n      queryClient.setQueryData([resource, 'getOne', {\n        id: String(record.id),\n        meta: meta\n      }], function (oldRecord) {\n        return oldRecord !== null && oldRecord !== void 0 ? oldRecord : record;\n      });\n    });\n    onSuccessEvent(result.data);\n  }, [queryClient, meta, onSuccessEvent, resource, result.data]);\n  useEffect(function () {\n    if (result.error == null) return;\n    onErrorEvent(result.error);\n  }, [onErrorEvent, result.error]);\n  useEffect(function () {\n    if (result.status === 'pending') return;\n    onSettledEvent(result.data, result.error);\n  }, [onSettledEvent, result.data, result.error, result.status]);\n  return useMemo(function () {\n    var _a, _b, _c;\n    return result.data ? __assign(__assign({}, result), {\n      data: (_a = result.data) === null || _a === void 0 ? void 0 : _a.data,\n      total: (_b = result.data) === null || _b === void 0 ? void 0 : _b.total,\n      pageInfo: (_c = result.data) === null || _c === void 0 ? void 0 : _c.pageInfo\n    }) : result;\n  }, [result]);\n};\nvar noop = function () {\n  return undefined;\n};","map":{"version":3,"names":["useEffect","useMemo","useQuery","useQueryClient","useDataProvider","useEvent","useGetManyReference","resource","params","options","target","id","_a","pagination","page","perPage","_b","sort","field","order","_c","filter","meta","dataProvider","queryClient","_d","onError","noop","_e","onSuccess","_f","onSettled","queryOptions","__rest","onSuccessEvent","onErrorEvent","onSettledEvent","result","__assign","queryKey","queryFn","queryParams","Promise","reject","Error","getManyReference","signal","supportAbortSignal","undefined","then","data","total","pageInfo","forEach","record","setQueryData","String","oldRecord","error","status"],"sources":["/Users/robertbinning/Documents/GitHub/robertbinning/passkey/node_modules/react-admin/node_modules/ra-core/src/dataProvider/useGetManyReference.ts"],"sourcesContent":["import { useEffect, useMemo } from 'react';\nimport {\n    useQuery,\n    UseQueryOptions,\n    UseQueryResult,\n    useQueryClient,\n} from '@tanstack/react-query';\n\nimport {\n    RaRecord,\n    GetManyReferenceParams,\n    GetManyReferenceResult,\n} from '../types';\nimport { useDataProvider } from './useDataProvider';\nimport { useEvent } from '../util';\n\n/**\n * Call the dataProvider.getManyReference() method and return the resolved result\n * as well as the loading state.\n *\n * The return value updates according to the request state:\n *\n * - start: { isPending: true, refetch }\n * - success: { data: [data from store], total: [total from response], isPending: false, refetch }\n * - error: { error: [error from response], isPending: false, refetch }\n *\n * This hook will return the cached result when called a second time\n * with the same parameters, until the response arrives.\n *\n * @param {string} resource The resource name, e.g. 'posts'\n * @param {Params} params The getManyReference parameters { target, id, pagination, sort, filter, meta }\n * @param {Object} options Options object to pass to the queryClient.\n * May include side effects to be executed upon success or failure, e.g. { onSuccess: () => { refresh(); } }\n *\n * @typedef Params\n * @prop params.target The target resource key, e.g. 'post_id'\n * @prop params.id The identifier of the record to look for in target, e.g. '123'\n * @prop params.pagination The request pagination { page, perPage }, e.g. { page: 1, perPage: 10 }\n * @prop params.sort The request sort { field, order }, e.g. { field: 'id', order: 'DESC' }\n * @prop params.filter The request filters, e.g. { title: 'hello, world' }\n * @prop params.meta Optional meta parameters\n *\n * @returns The current request state. Destructure as { data, total, error, isPending, refetch }.\n *\n * @example\n *\n * import { useGetManyReference, useRecordContext } from 'react-admin';\n *\n * const PostComments = () => {\n *     const record = useRecordContext();\n *     // fetch all comments related to the current record\n *     const { data, isPending, error } = useGetManyReference(\n *         'comments',\n *         { target: 'post_id', id: record.id, pagination: { page: 1, perPage: 10 }, sort: { field: 'published_at', order: 'DESC' } }\n *     );\n *     if (isPending) { return <Loading />; }\n *     if (error) { return <p>ERROR</p>; }\n *     return <ul>{data.map(comment =>\n *         <li key={comment.id}>{comment.body}</li>\n *     )}</ul>;\n * };\n */\nexport const useGetManyReference = <RecordType extends RaRecord = any>(\n    resource: string,\n    params: Partial<GetManyReferenceParams> = {},\n    options: UseGetManyReferenceHookOptions<RecordType> = {}\n): UseGetManyReferenceHookValue<RecordType> => {\n    const {\n        target,\n        id,\n        pagination = { page: 1, perPage: 25 },\n        sort = { field: 'id', order: 'DESC' },\n        filter = {},\n        meta,\n    } = params;\n    const dataProvider = useDataProvider();\n    const queryClient = useQueryClient();\n    const {\n        onError = noop,\n        onSuccess = noop,\n        onSettled = noop,\n        ...queryOptions\n    } = options;\n    const onSuccessEvent = useEvent(onSuccess);\n    const onErrorEvent = useEvent(onError);\n    const onSettledEvent = useEvent(onSettled);\n\n    const result = useQuery<\n        GetManyReferenceResult<RecordType>,\n        Error,\n        GetManyReferenceResult<RecordType>\n    >({\n        queryKey: [\n            resource,\n            'getManyReference',\n            { target, id, pagination, sort, filter, meta },\n        ],\n        queryFn: queryParams => {\n            if (!target || id == null) {\n                // check at runtime to support partial parameters with the enabled option\n                return Promise.reject(new Error('target and id are required'));\n            }\n\n            return dataProvider\n                .getManyReference<RecordType>(resource, {\n                    target,\n                    id,\n                    pagination,\n                    sort,\n                    filter,\n                    meta,\n                    signal:\n                        dataProvider.supportAbortSignal === true\n                            ? queryParams.signal\n                            : undefined,\n                })\n                .then(({ data, total, pageInfo }) => ({\n                    data,\n                    total,\n                    pageInfo,\n                }));\n        },\n        ...queryOptions,\n    });\n\n    useEffect(() => {\n        if (result.data === undefined) return;\n        // optimistically populate the getOne cache\n        result.data?.data?.forEach(record => {\n            queryClient.setQueryData(\n                [resource, 'getOne', { id: String(record.id), meta }],\n                oldRecord => oldRecord ?? record\n            );\n        });\n\n        onSuccessEvent(result.data);\n    }, [queryClient, meta, onSuccessEvent, resource, result.data]);\n\n    useEffect(() => {\n        if (result.error == null) return;\n        onErrorEvent(result.error);\n    }, [onErrorEvent, result.error]);\n\n    useEffect(() => {\n        if (result.status === 'pending') return;\n        onSettledEvent(result.data, result.error);\n    }, [onSettledEvent, result.data, result.error, result.status]);\n\n    return useMemo(\n        () =>\n            result.data\n                ? {\n                      ...result,\n                      data: result.data?.data,\n                      total: result.data?.total,\n                      pageInfo: result.data?.pageInfo,\n                  }\n                : result,\n        [result]\n    ) as UseQueryResult<RecordType[], Error> & {\n        total?: number;\n        pageInfo?: {\n            hasNextPage?: boolean;\n            hasPreviousPage?: boolean;\n        };\n    };\n};\n\nexport type UseGetManyReferenceHookOptions<RecordType extends RaRecord = any> =\n    Omit<\n        UseQueryOptions<GetManyReferenceResult<RecordType>>,\n        'queryKey' | 'queryFn'\n    > & {\n        onSuccess?: (data: GetManyReferenceResult<RecordType>) => void;\n        onError?: (error: Error) => void;\n        onSettled?: (\n            data?: GetManyReferenceResult<RecordType>,\n            error?: Error | null\n        ) => void;\n    };\n\nexport type UseGetManyReferenceHookValue<RecordType extends RaRecord = any> =\n    Omit<UseQueryResult<RecordType[]>, 'queryKey' | 'queryFn'> & {\n        total?: number;\n        pageInfo?: {\n            hasNextPage?: boolean;\n            hasPreviousPage?: boolean;\n        };\n    };\n\nconst noop = () => undefined;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}