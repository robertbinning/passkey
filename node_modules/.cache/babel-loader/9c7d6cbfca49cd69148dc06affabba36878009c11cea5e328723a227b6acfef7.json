{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { useEffect, useRef } from 'react';\nimport { useQuery, useQueryClient, hashKey } from '@tanstack/react-query';\nimport { useDataProvider } from './useDataProvider';\nimport { useEvent } from '../util';\n/**\n * Call the dataProvider.getMany() method and return the resolved result\n * as well as the loading state.\n *\n * The return value updates according to the request state:\n *\n * - start: { isPending: true, refetch }\n * - success: { data: [data from store], isPending: false, refetch }\n * - error: { error: [error from response], isPending: false, refetch }\n *\n * This hook will return the cached result when called a second time\n * with the same parameters, until the response arrives.\n *\n * @param {string} resource The resource name, e.g. 'posts'\n * @param {Params} params The getMany parameters { ids, meta }\n * @param {Object} options Options object to pass to the queryClient.\n * May include side effects to be executed upon success or failure, e.g. { onSuccess: () => { refresh(); } }\n *\n * @typedef Params\n * @prop params.ids The ids to get, e.g. [123, 456, 789]\n * @prop params.meta Optional meta parameters\n *\n * @returns The current request state. Destructure as { data, error, isPending, refetch }.\n *\n * @example\n *\n * import { useGetMany } from 'react-admin';\n *\n * const PostTags = ({ post }) => {\n *     const { data, isPending, error } = useGetMany(\n *         'tags',\n *         { ids: post.tags },\n *     );\n *     if (isPending) { return <Loading />; }\n *     if (error) { return <p>ERROR</p>; }\n *     return <ul>{data.map(tag =>\n *         <li key={tag.id}>{tag.name}</li>\n *     )}</ul>;\n * };\n */\nexport var useGetMany = function (resource, params, options) {\n  if (params === void 0) {\n    params = {};\n  }\n  if (options === void 0) {\n    options = {};\n  }\n  var ids = params.ids,\n    meta = params.meta;\n  var dataProvider = useDataProvider();\n  var queryClient = useQueryClient();\n  var queryCache = queryClient.getQueryCache();\n  var _a = options.onError,\n    onError = _a === void 0 ? noop : _a,\n    _b = options.onSuccess,\n    onSuccess = _b === void 0 ? noop : _b,\n    _c = options.onSettled,\n    onSettled = _c === void 0 ? noop : _c,\n    queryOptions = __rest(options, [\"onError\", \"onSuccess\", \"onSettled\"]);\n  var onSuccessEvent = useEvent(onSuccess);\n  var onErrorEvent = useEvent(onError);\n  var onSettledEvent = useEvent(onSettled);\n  var result = useQuery(__assign({\n    queryKey: [resource, 'getMany', {\n      ids: !ids || ids.length === 0 ? [] : ids.map(function (id) {\n        return String(id);\n      }),\n      meta: meta\n    }],\n    queryFn: function (queryParams) {\n      if (!ids || ids.length === 0) {\n        // no need to call the dataProvider\n        return Promise.resolve([]);\n      }\n      return dataProvider.getMany(resource, {\n        ids: ids,\n        meta: meta,\n        signal: dataProvider.supportAbortSignal === true ? queryParams.signal : undefined\n      }).then(function (_a) {\n        var data = _a.data;\n        return data;\n      });\n    },\n    placeholderData: function () {\n      var records = !ids || ids.length === 0 ? [] : ids.map(function (id) {\n        var _a, _b;\n        var queryHash = hashKey([resource, 'getOne', {\n          id: String(id),\n          meta: meta\n        }]);\n        return (_b = (_a = queryCache.get(queryHash)) === null || _a === void 0 ? void 0 : _a.state) === null || _b === void 0 ? void 0 : _b.data;\n      });\n      if (records.some(function (record) {\n        return record === undefined;\n      })) {\n        return undefined;\n      } else {\n        return records;\n      }\n    },\n    retry: false\n  }, queryOptions));\n  var metaValue = useRef(meta);\n  var resourceValue = useRef(resource);\n  useEffect(function () {\n    metaValue.current = meta;\n  }, [meta]);\n  useEffect(function () {\n    resourceValue.current = resource;\n  }, [resource]);\n  useEffect(function () {\n    if (result.data === undefined || result.error != null || result.isFetching) return;\n    // optimistically populate the getOne cache\n    result.data.forEach(function (record) {\n      queryClient.setQueryData([resourceValue.current, 'getOne', {\n        id: String(record.id),\n        meta: metaValue.current\n      }], function (oldRecord) {\n        return oldRecord !== null && oldRecord !== void 0 ? oldRecord : record;\n      });\n    });\n    onSuccessEvent(result.data);\n  }, [queryClient, onSuccessEvent, result.data, result.error, result.isFetching]);\n  useEffect(function () {\n    if (result.error == null || result.isFetching) return;\n    onErrorEvent(result.error);\n  }, [onErrorEvent, result.error, result.isFetching]);\n  useEffect(function () {\n    if (result.status === 'pending' || result.isFetching) return;\n    onSettledEvent(result.data, result.error);\n  }, [onSettledEvent, result.data, result.error, result.status, result.isFetching]);\n  return result;\n};\nvar noop = function () {\n  return undefined;\n};","map":{"version":3,"names":["useEffect","useRef","useQuery","useQueryClient","hashKey","useDataProvider","useEvent","useGetMany","resource","params","options","ids","meta","dataProvider","queryClient","queryCache","getQueryCache","_a","onError","noop","_b","onSuccess","_c","onSettled","queryOptions","__rest","onSuccessEvent","onErrorEvent","onSettledEvent","result","__assign","queryKey","length","map","id","String","queryFn","queryParams","Promise","resolve","getMany","signal","supportAbortSignal","undefined","then","data","placeholderData","records","queryHash","get","state","some","record","retry","metaValue","resourceValue","current","error","isFetching","forEach","setQueryData","oldRecord","status"],"sources":["/Users/robertbinning/Documents/GitHub/robertbinning/passkey/node_modules/react-admin/node_modules/ra-core/src/dataProvider/useGetMany.ts"],"sourcesContent":["import { useEffect, useRef } from 'react';\nimport {\n    useQuery,\n    UseQueryOptions,\n    UseQueryResult,\n    useQueryClient,\n    hashKey,\n} from '@tanstack/react-query';\n\nimport { RaRecord, GetManyParams } from '../types';\nimport { useDataProvider } from './useDataProvider';\nimport { useEvent } from '../util';\n\n/**\n * Call the dataProvider.getMany() method and return the resolved result\n * as well as the loading state.\n *\n * The return value updates according to the request state:\n *\n * - start: { isPending: true, refetch }\n * - success: { data: [data from store], isPending: false, refetch }\n * - error: { error: [error from response], isPending: false, refetch }\n *\n * This hook will return the cached result when called a second time\n * with the same parameters, until the response arrives.\n *\n * @param {string} resource The resource name, e.g. 'posts'\n * @param {Params} params The getMany parameters { ids, meta }\n * @param {Object} options Options object to pass to the queryClient.\n * May include side effects to be executed upon success or failure, e.g. { onSuccess: () => { refresh(); } }\n *\n * @typedef Params\n * @prop params.ids The ids to get, e.g. [123, 456, 789]\n * @prop params.meta Optional meta parameters\n *\n * @returns The current request state. Destructure as { data, error, isPending, refetch }.\n *\n * @example\n *\n * import { useGetMany } from 'react-admin';\n *\n * const PostTags = ({ post }) => {\n *     const { data, isPending, error } = useGetMany(\n *         'tags',\n *         { ids: post.tags },\n *     );\n *     if (isPending) { return <Loading />; }\n *     if (error) { return <p>ERROR</p>; }\n *     return <ul>{data.map(tag =>\n *         <li key={tag.id}>{tag.name}</li>\n *     )}</ul>;\n * };\n */\nexport const useGetMany = <RecordType extends RaRecord = any>(\n    resource: string,\n    params: Partial<GetManyParams> = {},\n    options: UseGetManyOptions<RecordType> = {}\n): UseGetManyHookValue<RecordType> => {\n    const { ids, meta } = params;\n    const dataProvider = useDataProvider();\n    const queryClient = useQueryClient();\n    const queryCache = queryClient.getQueryCache();\n    const {\n        onError = noop,\n        onSuccess = noop,\n        onSettled = noop,\n        ...queryOptions\n    } = options;\n    const onSuccessEvent = useEvent(onSuccess);\n    const onErrorEvent = useEvent(onError);\n    const onSettledEvent = useEvent(onSettled);\n\n    const result = useQuery<RecordType[], Error, RecordType[]>({\n        queryKey: [\n            resource,\n            'getMany',\n            {\n                ids: !ids || ids.length === 0 ? [] : ids.map(id => String(id)),\n                meta,\n            },\n        ],\n        queryFn: queryParams => {\n            if (!ids || ids.length === 0) {\n                // no need to call the dataProvider\n                return Promise.resolve([]);\n            }\n            return dataProvider\n                .getMany<RecordType>(resource, {\n                    ids,\n                    meta,\n                    signal:\n                        dataProvider.supportAbortSignal === true\n                            ? queryParams.signal\n                            : undefined,\n                })\n                .then(({ data }) => data);\n        },\n        placeholderData: () => {\n            const records =\n                !ids || ids.length === 0\n                    ? []\n                    : ids.map(id => {\n                          const queryHash = hashKey([\n                              resource,\n                              'getOne',\n                              { id: String(id), meta },\n                          ]);\n                          return queryCache.get<RecordType>(queryHash)?.state\n                              ?.data;\n                      });\n            if (records.some(record => record === undefined)) {\n                return undefined;\n            } else {\n                return records as RecordType[];\n            }\n        },\n        retry: false,\n        ...queryOptions,\n    });\n\n    const metaValue = useRef(meta);\n    const resourceValue = useRef(resource);\n\n    useEffect(() => {\n        metaValue.current = meta;\n    }, [meta]);\n\n    useEffect(() => {\n        resourceValue.current = resource;\n    }, [resource]);\n\n    useEffect(() => {\n        if (\n            result.data === undefined ||\n            result.error != null ||\n            result.isFetching\n        )\n            return;\n        // optimistically populate the getOne cache\n        result.data.forEach(record => {\n            queryClient.setQueryData(\n                [\n                    resourceValue.current,\n                    'getOne',\n                    { id: String(record.id), meta: metaValue.current },\n                ],\n                oldRecord => oldRecord ?? record\n            );\n        });\n\n        onSuccessEvent(result.data);\n    }, [\n        queryClient,\n        onSuccessEvent,\n        result.data,\n        result.error,\n        result.isFetching,\n    ]);\n\n    useEffect(() => {\n        if (result.error == null || result.isFetching) return;\n        onErrorEvent(result.error);\n    }, [onErrorEvent, result.error, result.isFetching]);\n\n    useEffect(() => {\n        if (result.status === 'pending' || result.isFetching) return;\n        onSettledEvent(result.data, result.error);\n    }, [\n        onSettledEvent,\n        result.data,\n        result.error,\n        result.status,\n        result.isFetching,\n    ]);\n\n    return result;\n};\n\nconst noop = () => undefined;\n\nexport type UseGetManyOptions<RecordType extends RaRecord = any> = Omit<\n    UseQueryOptions<RecordType[], Error>,\n    'queryKey' | 'queryFn'\n> & {\n    onSuccess?: (data: RecordType[]) => void;\n    onError?: (error: Error) => void;\n    onSettled?: (data?: RecordType[], error?: Error | null) => void;\n};\n\nexport type UseGetManyHookValue<RecordType extends RaRecord = any> =\n    UseQueryResult<RecordType[], Error>;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}