{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { useEffect } from 'react';\nimport { useQuery } from '@tanstack/react-query';\nimport { useLocation } from 'react-router';\nimport { useRedirect } from '../routing';\nimport useAuthProvider from './useAuthProvider';\nimport { useEvent } from '../util';\n/**\n * This hook calls the `authProvider.handleCallback()` method on mount. This is meant to be used in a route called\n * by an external authentication service (e.g. Auth0) after the user has logged in.\n * By default, it redirects to application home page upon success, or to the `redirectTo` location returned by `authProvider. handleCallback`.\n *\n * @returns An object containing { isPending, data, error, refetch }.\n */\nexport var useHandleAuthCallback = function (options) {\n  var authProvider = useAuthProvider();\n  var redirect = useRedirect();\n  var location = useLocation();\n  var locationState = location.state;\n  var nextPathName = locationState && locationState.nextPathname;\n  var nextSearch = locationState && locationState.nextSearch;\n  var defaultRedirectUrl = nextPathName ? nextPathName + nextSearch : '/';\n  var _a = options !== null && options !== void 0 ? options : {},\n    onSuccess = _a.onSuccess,\n    onError = _a.onError,\n    onSettled = _a.onSettled,\n    queryOptions = __rest(_a, [\"onSuccess\", \"onError\", \"onSettled\"]);\n  var queryResult = useQuery(__assign({\n    queryKey: ['auth', 'handleCallback'],\n    queryFn: function (_a) {\n      var signal = _a.signal;\n      return authProvider && typeof authProvider.handleCallback === 'function' ? authProvider.handleCallback({\n        signal: signal\n      }).then(function (result) {\n        return result !== null && result !== void 0 ? result : null;\n      }) : Promise.resolve();\n    },\n    retry: false\n  }, queryOptions));\n  var onSuccessEvent = useEvent(onSuccess !== null && onSuccess !== void 0 ? onSuccess : function (data) {\n    var _a;\n    // AuthProviders relying on a third party services redirect back to the app can't\n    // use the location state to store the path on which the user was before the login.\n    // So we support a fallback on the localStorage.\n    var previousLocation = localStorage.getItem(PreviousLocationStorageKey);\n    var redirectTo = (_a = data === null || data === void 0 ? void 0 : data.redirectTo) !== null && _a !== void 0 ? _a : previousLocation;\n    if (redirectTo === false) {\n      return;\n    }\n    redirect(redirectTo !== null && redirectTo !== void 0 ? redirectTo : defaultRedirectUrl);\n  });\n  var onErrorEvent = useEvent(onError !== null && onError !== void 0 ? onError : noop);\n  var onSettledEvent = useEvent(onSettled !== null && onSettled !== void 0 ? onSettled : noop);\n  useEffect(function () {\n    if (queryResult.error == null || queryResult.isFetching) return;\n    onErrorEvent(queryResult.error);\n  }, [onErrorEvent, queryResult.error, queryResult.isFetching]);\n  useEffect(function () {\n    if (queryResult.data === undefined || queryResult.isFetching) return;\n    onSuccessEvent(queryResult.data);\n  }, [onSuccessEvent, queryResult.data, queryResult.isFetching]);\n  useEffect(function () {\n    if (queryResult.status === 'pending' || queryResult.isFetching) return;\n    onSettledEvent(queryResult.data, queryResult.error);\n  }, [onSettledEvent, queryResult.data, queryResult.error, queryResult.status, queryResult.isFetching]);\n  return queryResult;\n};\n/**\n * Key used to store the previous location in localStorage.\n * Used by the useHandleAuthCallback hook to redirect the user to their previous location after a successful login.\n */\nexport var PreviousLocationStorageKey = '@react-admin/nextPathname';\nvar noop = function () {};","map":{"version":3,"names":["useEffect","useQuery","useLocation","useRedirect","useAuthProvider","useEvent","useHandleAuthCallback","options","authProvider","redirect","location","locationState","state","nextPathName","nextPathname","nextSearch","defaultRedirectUrl","_a","onSuccess","onError","onSettled","queryOptions","__rest","queryResult","__assign","queryKey","queryFn","signal","handleCallback","then","result","Promise","resolve","retry","onSuccessEvent","data","previousLocation","localStorage","getItem","PreviousLocationStorageKey","redirectTo","onErrorEvent","noop","onSettledEvent","error","isFetching","undefined","status"],"sources":["/Users/robertbinning/Documents/GitHub/robertbinning/passkey/node_modules/react-admin/node_modules/ra-core/src/auth/useHandleAuthCallback.ts"],"sourcesContent":["import { useEffect } from 'react';\nimport { useQuery, UseQueryOptions } from '@tanstack/react-query';\nimport { useLocation } from 'react-router';\nimport { useRedirect } from '../routing';\nimport { AuthRedirectResult } from '../types';\nimport useAuthProvider from './useAuthProvider';\nimport { useEvent } from '../util';\n\n/**\n * This hook calls the `authProvider.handleCallback()` method on mount. This is meant to be used in a route called\n * by an external authentication service (e.g. Auth0) after the user has logged in.\n * By default, it redirects to application home page upon success, or to the `redirectTo` location returned by `authProvider. handleCallback`.\n *\n * @returns An object containing { isPending, data, error, refetch }.\n */\nexport const useHandleAuthCallback = (\n    options?: UseHandleAuthCallbackOptions\n) => {\n    const authProvider = useAuthProvider();\n    const redirect = useRedirect();\n    const location = useLocation();\n    const locationState = location.state as any;\n    const nextPathName = locationState && locationState.nextPathname;\n    const nextSearch = locationState && locationState.nextSearch;\n    const defaultRedirectUrl = nextPathName ? nextPathName + nextSearch : '/';\n    const { onSuccess, onError, onSettled, ...queryOptions } = options ?? {};\n\n    const queryResult = useQuery({\n        queryKey: ['auth', 'handleCallback'],\n        queryFn: ({ signal }) =>\n            authProvider && typeof authProvider.handleCallback === 'function'\n                ? authProvider\n                      .handleCallback({ signal })\n                      .then(result => result ?? null)\n                : Promise.resolve(),\n        retry: false,\n        ...queryOptions,\n    });\n\n    const onSuccessEvent = useEvent(\n        onSuccess ??\n            ((data: any) => {\n                // AuthProviders relying on a third party services redirect back to the app can't\n                // use the location state to store the path on which the user was before the login.\n                // So we support a fallback on the localStorage.\n                const previousLocation = localStorage.getItem(\n                    PreviousLocationStorageKey\n                );\n                const redirectTo =\n                    (data as AuthRedirectResult)?.redirectTo ??\n                    previousLocation;\n                if (redirectTo === false) {\n                    return;\n                }\n\n                redirect(redirectTo ?? defaultRedirectUrl);\n            })\n    );\n    const onErrorEvent = useEvent(onError ?? noop);\n    const onSettledEvent = useEvent(onSettled ?? noop);\n\n    useEffect(() => {\n        if (queryResult.error == null || queryResult.isFetching) return;\n        onErrorEvent(queryResult.error);\n    }, [onErrorEvent, queryResult.error, queryResult.isFetching]);\n\n    useEffect(() => {\n        if (queryResult.data === undefined || queryResult.isFetching) return;\n        onSuccessEvent(queryResult.data);\n    }, [onSuccessEvent, queryResult.data, queryResult.isFetching]);\n\n    useEffect(() => {\n        if (queryResult.status === 'pending' || queryResult.isFetching) return;\n        onSettledEvent(queryResult.data, queryResult.error);\n    }, [\n        onSettledEvent,\n        queryResult.data,\n        queryResult.error,\n        queryResult.status,\n        queryResult.isFetching,\n    ]);\n\n    return queryResult;\n};\n\n/**\n * Key used to store the previous location in localStorage.\n * Used by the useHandleAuthCallback hook to redirect the user to their previous location after a successful login.\n */\nexport const PreviousLocationStorageKey = '@react-admin/nextPathname';\n\nexport type UseHandleAuthCallbackOptions = Omit<\n    UseQueryOptions<AuthRedirectResult | void>,\n    'queryKey' | 'queryFn'\n> & {\n    onSuccess?: (data: AuthRedirectResult | void) => void;\n    onError?: (err: Error) => void;\n    onSettled?: (\n        data?: AuthRedirectResult | void,\n        error?: Error | null\n    ) => void;\n};\n\nconst noop = () => {};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}