{"ast":null,"code":"import get from 'lodash/get';\nimport { useRecordContext } from '../controller';\n/**\n * A hook that gets the value of a field of the current record.\n * @param params The hook parameters\n * @param params.source The field source\n * @param params.record The record to use. Uses the record from the RecordContext if not provided\n * @param params.defaultValue The value to return when the field value is empty\n * @returns The field value\n *\n * @example\n * const MyField = (props: { source: string }) => {\n *   const value = useFieldValue(props);\n *   return <span>{value}</span>;\n * }\n */\nexport var useFieldValue = function (params) {\n  var defaultValue = params.defaultValue,\n    source = params.source;\n  // We use the record from the RecordContext and do not rely on the SourceContext on purpose to\n  // avoid having the wrong source targeting the record.\n  // Indeed, some components may create a sub record context (SimpleFormIterator, TranslatableInputs, etc.). In this case,\n  // it they used the SourceContext as well, they would have the wrong source.\n  // Inputs needs the SourceContext as they rely on the Form value and you can't have nested forms.\n  // Fields needs the RecordContext as they rely on the Record value and you can have nested RecordContext.\n  var record = useRecordContext(params);\n  return get(record, source, defaultValue);\n};","map":{"version":3,"names":["get","useRecordContext","useFieldValue","params","defaultValue","source","record"],"sources":["/Users/robertbinning/Documents/GitHub/robertbinning/passkey/node_modules/react-admin/node_modules/ra-core/src/util/useFieldValue.ts"],"sourcesContent":["import get from 'lodash/get';\nimport { Call, Objects } from 'hotscript';\nimport { useRecordContext } from '../controller';\n\n/**\n * A hook that gets the value of a field of the current record.\n * @param params The hook parameters\n * @param params.source The field source\n * @param params.record The record to use. Uses the record from the RecordContext if not provided\n * @param params.defaultValue The value to return when the field value is empty\n * @returns The field value\n *\n * @example\n * const MyField = (props: { source: string }) => {\n *   const value = useFieldValue(props);\n *   return <span>{value}</span>;\n * }\n */\nexport const useFieldValue = <\n    RecordType extends Record<string, any> = Record<string, any>,\n>(\n    params: UseFieldValueOptions<RecordType>\n) => {\n    const { defaultValue, source } = params;\n    // We use the record from the RecordContext and do not rely on the SourceContext on purpose to\n    // avoid having the wrong source targeting the record.\n    // Indeed, some components may create a sub record context (SimpleFormIterator, TranslatableInputs, etc.). In this case,\n    // it they used the SourceContext as well, they would have the wrong source.\n    // Inputs needs the SourceContext as they rely on the Form value and you can't have nested forms.\n    // Fields needs the RecordContext as they rely on the Record value and you can have nested RecordContext.\n    const record = useRecordContext<RecordType>(params);\n\n    return get(record, source, defaultValue);\n};\n\nexport interface UseFieldValueOptions<\n    RecordType extends Record<string, any> = Record<string, any>,\n> {\n    // FIXME: Find a way to throw a type error when defaultValue is not of RecordType[Source] type\n    defaultValue?: any;\n    source: Call<Objects.AllPaths, RecordType> extends never\n        ? AnyString\n        : Call<Objects.AllPaths, RecordType>;\n    record?: RecordType;\n}\n\ntype AnyString = string & {};\n"],"mappings":"AAAA,OAAOA,GAAG,MAAM,YAAY;AAE5B,SAASC,gBAAgB,QAAQ,eAAe;AAEhD;;;;;;;;;;;;;;AAcA,OAAO,IAAMC,aAAa,GAAG,SAAAA,CAGzBC,MAAwC;EAEhC,IAAAC,YAAY,GAAaD,MAAM,CAAAC,YAAnB;IAAEC,MAAM,GAAKF,MAAM,CAAAE,MAAX;EAC5B;EACA;EACA;EACA;EACA;EACA;EACA,IAAMC,MAAM,GAAGL,gBAAgB,CAAaE,MAAM,CAAC;EAEnD,OAAOH,GAAG,CAACM,MAAM,EAAED,MAAM,EAAED,YAAY,CAAC;AAC5C,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}