{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { useEffect, useMemo, useRef } from 'react';\nimport { useQueryClient, useQuery, hashKey } from '@tanstack/react-query';\nimport union from 'lodash/union';\nimport { useDataProvider } from './useDataProvider';\nimport { useEvent } from '../util';\n/**\n * Call the dataProvider.getMany() method and return the resolved result\n * as well as the loading state.\n *\n * The return value updates according to the request state:\n *\n * - start: { isPending: true, isFetching: true, refetch }\n * - success: { data: [data from response], isPending: false, isFetching: false, refetch }\n * - error: { error: [error from response], isPending: false, isFetching: false, refetch }\n *\n * This hook will return the cached result when called a second time\n * with the same parameters, until the response arrives.\n *\n * This hook aggregates and deduplicates calls to the same resource, so for instance, if an app calls:\n *\n * useGetManyAggregate('tags', [1, 2, 3]);\n * useGetManyAggregate('tags', [3, 4]);\n *\n * during the same tick, the hook will only call the dataProvider once with the following parameters:\n *\n * dataProvider.getMany('tags', [1, 2, 3, 4])\n *\n * @param resource The resource name, e.g. 'posts'\n * @param {Params} params The getMany parameters { ids, meta }\n * @param {Object} options Options object to pass to the dataProvider.\n * @param {boolean} options.enabled Flag to conditionally run the query. If it's false, the query will not run\n * @param {Function} options.onSuccess Side effect function to be executed upon success, e.g. { onSuccess: { refresh: true } }\n * @param {Function} options.onError Side effect function to be executed upon failure, e.g. { onError: error => notify(error.message) }\n *\n * @typedef Params\n * @prop params.ids The ids to get, e.g. [123, 456, 789]\n * @prop params.meta Optional meta parameters\n\n * @returns The current request state. Destructure as { data, error, isPending, isFetching, refetch }.\n *\n * @example\n *\n * import { useGetManyAggregate, useRecordContext } from 'react-admin';\n *\n * const PostTags = () => {\n *     const record = useRecordContext();\n *     const { data, isPending, error } = useGetManyAggregate('tags', { ids: record.tagIds });\n *     if (isPending) { return <Loading />; }\n *     if (error) { return <p>ERROR</p>; }\n *     return (\n *          <ul>\n *              {data.map(tag => (\n *                  <li key={tag.id}>{tag.name}</li>\n *              ))}\n *          </ul>\n *      );\n * };\n */\nexport var useGetManyAggregate = function (resource, params, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var dataProvider = useDataProvider();\n  var queryClient = useQueryClient();\n  var queryCache = queryClient.getQueryCache();\n  var _a = options.onError,\n    onError = _a === void 0 ? noop : _a,\n    _b = options.onSuccess,\n    onSuccess = _b === void 0 ? noop : _b,\n    _c = options.onSettled,\n    onSettled = _c === void 0 ? noop : _c,\n    queryOptions = __rest(options, [\"onError\", \"onSuccess\", \"onSettled\"]);\n  var onSuccessEvent = useEvent(onSuccess);\n  var onErrorEvent = useEvent(onError);\n  var onSettledEvent = useEvent(onSettled);\n  var ids = params.ids,\n    meta = params.meta;\n  var placeholderData = useMemo(function () {\n    var records = (Array.isArray(ids) ? ids : [ids]).map(function (id) {\n      var _a, _b;\n      var queryHash = hashKey([resource, 'getOne', {\n        id: String(id),\n        meta: meta\n      }]);\n      return (_b = (_a = queryCache.get(queryHash)) === null || _a === void 0 ? void 0 : _a.state) === null || _b === void 0 ? void 0 : _b.data;\n    });\n    if (records.some(function (record) {\n      return record === undefined;\n    })) {\n      return undefined;\n    } else {\n      return records;\n    }\n  }, [ids, queryCache, resource, meta]);\n  var result = useQuery(__assign({\n    queryKey: [resource, 'getMany', {\n      ids: (Array.isArray(ids) ? ids : [ids]).map(function (id) {\n        return String(id);\n      }),\n      meta: meta\n    }],\n    queryFn: function (queryParams) {\n      return new Promise(function (resolve, reject) {\n        if (!ids || ids.length === 0) {\n          // no need to call the dataProvider\n          return resolve([]);\n        }\n        // debounced / batched fetch\n        return callGetManyQueries({\n          resource: resource,\n          ids: ids,\n          meta: meta,\n          resolve: resolve,\n          reject: reject,\n          dataProvider: dataProvider,\n          queryClient: queryClient,\n          signal: dataProvider.supportAbortSignal === true ? queryParams.signal : undefined\n        });\n      });\n    },\n    placeholderData: placeholderData,\n    retry: false\n  }, queryOptions));\n  var metaValue = useRef(meta);\n  var resourceValue = useRef(resource);\n  useEffect(function () {\n    metaValue.current = meta;\n  }, [meta]);\n  useEffect(function () {\n    resourceValue.current = resource;\n  }, [resource]);\n  useEffect(function () {\n    var _a;\n    if (result.data === undefined || result.error != null || result.isFetching) return;\n    // optimistically populate the getOne cache\n    ((_a = result.data) !== null && _a !== void 0 ? _a : []).forEach(function (record) {\n      queryClient.setQueryData([resourceValue.current, 'getOne', {\n        id: String(record.id),\n        meta: metaValue.current\n      }], function (oldRecord) {\n        return oldRecord !== null && oldRecord !== void 0 ? oldRecord : record;\n      });\n    });\n    onSuccessEvent(result.data);\n  }, [queryClient, onSuccessEvent, result.data, result.error, result.isFetching]);\n  useEffect(function () {\n    if (result.error == null || result.isFetching) return;\n    onErrorEvent(result.error);\n  }, [onErrorEvent, result.error, result.isFetching]);\n  useEffect(function () {\n    if (result.status === 'pending' || result.isFetching) return;\n    onSettledEvent(result.data, result.error);\n  }, [onSettledEvent, result.data, result.error, result.status, result.isFetching]);\n  return result;\n};\n/**\n * Batch all calls to a function into one single call with the arguments of all the calls.\n *\n * @example\n * let sum = 0;\n * const add = (args) => { sum = args.reduce((arg, total) => total + arg, 0); };\n * const addBatched = batch(add);\n * addBatched(2);\n * addBatched(8);\n * // add will be called once with arguments [2, 8]\n * // and sum will be equal to 10\n */\nvar batch = function (fn) {\n  var capturedArgs = [];\n  var timeout = null;\n  return function (arg) {\n    capturedArgs.push(arg);\n    if (timeout) clearTimeout(timeout);\n    timeout = setTimeout(function () {\n      timeout = null;\n      fn(__spreadArray([], capturedArgs, true));\n      capturedArgs = [];\n    }, 0);\n  };\n};\n/**\n * Group and execute all calls to the dataProvider.getMany() method for the current tick\n *\n * Thanks to batch(), this function executes at most once per tick,\n * whatever the number of calls to useGetManyAggregate().\n */\nvar callGetManyQueries = batch(function (calls) {\n  var dataProvider = calls[0].dataProvider;\n  var queryClient = calls[0].queryClient;\n  /**\n   * Aggregate calls by resource\n   *\n   * callsByResource will look like:\n   * {\n   *     posts: [{ resource, ids, resolve, reject, dataProvider, queryClient }, ...],\n   *     tags: [{ resource, ids, resolve, reject, dataProvider, queryClient }, ...],\n   * }\n   */\n  var callsByResource = calls.reduce(function (acc, callArgs) {\n    if (!acc[callArgs.resource]) {\n      acc[callArgs.resource] = [];\n    }\n    acc[callArgs.resource].push(callArgs);\n    return acc;\n  }, {});\n  /**\n   * For each resource, aggregate ids and call dataProvider.getMany() once\n   */\n  Object.keys(callsByResource).forEach(function (resource) {\n    var callsForResource = callsByResource[resource];\n    /**\n     * Extract ids from queries, aggregate and deduplicate them\n     *\n     * @example from [[1, 2], [2, null, 3], [4, null]] to [1, 2, 3, 4]\n     */\n    var aggregatedIds = callsForResource.reduce(function (acc, _a) {\n      var ids = _a.ids;\n      return union(acc, ids);\n    }, []) // concat + unique\n    .filter(function (v) {\n      return v != null && v !== '';\n    }); // remove null values\n    var uniqueMeta = callsForResource.reduce(function (acc, _a) {\n      var meta = _a.meta;\n      return meta || acc;\n    }, undefined);\n    if (aggregatedIds.length === 0) {\n      // no need to call the data provider if all the ids are null\n      callsForResource.forEach(function (_a) {\n        var resolve = _a.resolve;\n        resolve([]);\n      });\n      return;\n    }\n    var callThatHasAllAggregatedIds = callsForResource.find(function (_a) {\n      var ids = _a.ids,\n        signal = _a.signal;\n      return JSON.stringify(ids) === JSON.stringify(aggregatedIds) && !(signal === null || signal === void 0 ? void 0 : signal.aborted);\n    });\n    if (callThatHasAllAggregatedIds) {\n      // There is only one call (no aggregation), or one of the calls has the same ids as the sum of all calls.\n      // Either way, we can't trigger a new fetchQuery with the same signature, as it's already pending.\n      // Therefore, we reply with the dataProvider\n      var dataProvider_1 = callThatHasAllAggregatedIds.dataProvider,\n        resource_1 = callThatHasAllAggregatedIds.resource,\n        ids = callThatHasAllAggregatedIds.ids,\n        meta = callThatHasAllAggregatedIds.meta,\n        signal = callThatHasAllAggregatedIds.signal;\n      dataProvider_1.getMany(resource_1, {\n        ids: ids,\n        meta: meta,\n        signal: signal\n      }).then(function (_a) {\n        var data = _a.data;\n        return data;\n      }).then(function (data) {\n        // We must then resolve all the pending calls with the data they requested\n        callsForResource.forEach(function (_a) {\n          var ids = _a.ids,\n            resolve = _a.resolve;\n          resolve(data.filter(function (record) {\n            return ids.map(function (id) {\n              return String(id);\n            }).includes(String(record.id));\n          }));\n        });\n      }, function (error) {\n        // All pending calls must also receive the error\n        callsForResource.forEach(function (_a) {\n          var reject = _a.reject;\n          reject(error);\n        });\n      });\n      return;\n    }\n    /**\n     * Call dataProvider.getMany() with the aggregatedIds,\n     * and resolve each of the promises using the results\n     */\n    queryClient.fetchQuery({\n      queryKey: [resource, 'getMany', {\n        ids: aggregatedIds.map(function (id) {\n          return String(id);\n        }),\n        meta: uniqueMeta\n      }],\n      queryFn: function (queryParams) {\n        return dataProvider.getMany(resource, {\n          ids: aggregatedIds,\n          meta: uniqueMeta,\n          signal: dataProvider.supportAbortSignal === true ? queryParams.signal : undefined\n        }).then(function (_a) {\n          var data = _a.data;\n          return data;\n        });\n      }\n    }).then(function (data) {\n      callsForResource.forEach(function (_a) {\n        var ids = _a.ids,\n          resolve = _a.resolve;\n        resolve(data.filter(function (record) {\n          return ids.map(function (id) {\n            return String(id);\n          }).includes(String(record.id));\n        }));\n      });\n    }).catch(function (error) {\n      return callsForResource.forEach(function (_a) {\n        var reject = _a.reject;\n        return reject(error);\n      });\n    });\n  });\n});\nvar noop = function () {\n  return undefined;\n};","map":{"version":3,"names":["useEffect","useMemo","useRef","useQueryClient","useQuery","hashKey","union","useDataProvider","useEvent","useGetManyAggregate","resource","params","options","dataProvider","queryClient","queryCache","getQueryCache","_a","onError","noop","_b","onSuccess","_c","onSettled","queryOptions","__rest","onSuccessEvent","onErrorEvent","onSettledEvent","ids","meta","placeholderData","records","Array","isArray","map","id","queryHash","String","get","state","data","some","record","undefined","result","__assign","queryKey","queryFn","queryParams","Promise","resolve","reject","length","callGetManyQueries","signal","supportAbortSignal","retry","metaValue","resourceValue","current","error","isFetching","forEach","setQueryData","oldRecord","status","batch","fn","capturedArgs","timeout","arg","push","clearTimeout","setTimeout","__spreadArray","calls","callsByResource","reduce","acc","callArgs","Object","keys","callsForResource","aggregatedIds","filter","v","uniqueMeta","callThatHasAllAggregatedIds","find","JSON","stringify","aborted","dataProvider_1","resource_1","getMany","then","includes","fetchQuery","catch"],"sources":["/Users/robertbinning/Documents/GitHub/robertbinning/passkey/node_modules/react-admin/node_modules/ra-core/src/dataProvider/useGetManyAggregate.ts"],"sourcesContent":["import { useEffect, useMemo, useRef } from 'react';\nimport {\n    QueryClient,\n    useQueryClient,\n    useQuery,\n    UseQueryOptions,\n    hashKey,\n} from '@tanstack/react-query';\nimport union from 'lodash/union';\n\nimport { UseGetManyHookValue } from './useGetMany';\nimport { Identifier, RaRecord, GetManyParams, DataProvider } from '../types';\nimport { useDataProvider } from './useDataProvider';\nimport { useEvent } from '../util';\n\n/**\n * Call the dataProvider.getMany() method and return the resolved result\n * as well as the loading state.\n *\n * The return value updates according to the request state:\n *\n * - start: { isPending: true, isFetching: true, refetch }\n * - success: { data: [data from response], isPending: false, isFetching: false, refetch }\n * - error: { error: [error from response], isPending: false, isFetching: false, refetch }\n *\n * This hook will return the cached result when called a second time\n * with the same parameters, until the response arrives.\n *\n * This hook aggregates and deduplicates calls to the same resource, so for instance, if an app calls:\n *\n * useGetManyAggregate('tags', [1, 2, 3]);\n * useGetManyAggregate('tags', [3, 4]);\n *\n * during the same tick, the hook will only call the dataProvider once with the following parameters:\n *\n * dataProvider.getMany('tags', [1, 2, 3, 4])\n *\n * @param resource The resource name, e.g. 'posts'\n * @param {Params} params The getMany parameters { ids, meta }\n * @param {Object} options Options object to pass to the dataProvider.\n * @param {boolean} options.enabled Flag to conditionally run the query. If it's false, the query will not run\n * @param {Function} options.onSuccess Side effect function to be executed upon success, e.g. { onSuccess: { refresh: true } }\n * @param {Function} options.onError Side effect function to be executed upon failure, e.g. { onError: error => notify(error.message) }\n *\n * @typedef Params\n * @prop params.ids The ids to get, e.g. [123, 456, 789]\n * @prop params.meta Optional meta parameters\n\n * @returns The current request state. Destructure as { data, error, isPending, isFetching, refetch }.\n *\n * @example\n *\n * import { useGetManyAggregate, useRecordContext } from 'react-admin';\n *\n * const PostTags = () => {\n *     const record = useRecordContext();\n *     const { data, isPending, error } = useGetManyAggregate('tags', { ids: record.tagIds });\n *     if (isPending) { return <Loading />; }\n *     if (error) { return <p>ERROR</p>; }\n *     return (\n *          <ul>\n *              {data.map(tag => (\n *                  <li key={tag.id}>{tag.name}</li>\n *              ))}\n *          </ul>\n *      );\n * };\n */\nexport const useGetManyAggregate = <RecordType extends RaRecord = any>(\n    resource: string,\n    params: GetManyParams,\n    options: UseGetManyAggregateOptions<RecordType> = {}\n): UseGetManyHookValue<RecordType> => {\n    const dataProvider = useDataProvider();\n    const queryClient = useQueryClient();\n    const queryCache = queryClient.getQueryCache();\n    const {\n        onError = noop,\n        onSuccess = noop,\n        onSettled = noop,\n        ...queryOptions\n    } = options;\n    const onSuccessEvent = useEvent(onSuccess);\n    const onErrorEvent = useEvent(onError);\n    const onSettledEvent = useEvent(onSettled);\n\n    const { ids, meta } = params;\n    const placeholderData = useMemo(() => {\n        const records = (Array.isArray(ids) ? ids : [ids]).map(id => {\n            const queryHash = hashKey([\n                resource,\n                'getOne',\n                { id: String(id), meta },\n            ]);\n            return queryCache.get<RecordType>(queryHash)?.state?.data;\n        });\n        if (records.some(record => record === undefined)) {\n            return undefined;\n        } else {\n            return records as RecordType[];\n        }\n    }, [ids, queryCache, resource, meta]);\n\n    const result = useQuery<RecordType[], Error, RecordType[]>({\n        queryKey: [\n            resource,\n            'getMany',\n            {\n                ids: (Array.isArray(ids) ? ids : [ids]).map(id => String(id)),\n                meta,\n            },\n        ],\n        queryFn: queryParams =>\n            new Promise((resolve, reject) => {\n                if (!ids || ids.length === 0) {\n                    // no need to call the dataProvider\n                    return resolve([]);\n                }\n\n                // debounced / batched fetch\n                return callGetManyQueries({\n                    resource,\n                    ids,\n                    meta,\n                    resolve,\n                    reject,\n                    dataProvider,\n                    queryClient,\n                    signal:\n                        dataProvider.supportAbortSignal === true\n                            ? queryParams.signal\n                            : undefined,\n                });\n            }),\n        placeholderData,\n        retry: false,\n        ...queryOptions,\n    });\n\n    const metaValue = useRef(meta);\n    const resourceValue = useRef(resource);\n\n    useEffect(() => {\n        metaValue.current = meta;\n    }, [meta]);\n\n    useEffect(() => {\n        resourceValue.current = resource;\n    }, [resource]);\n\n    useEffect(() => {\n        if (\n            result.data === undefined ||\n            result.error != null ||\n            result.isFetching\n        )\n            return;\n\n        // optimistically populate the getOne cache\n        (result.data ?? []).forEach(record => {\n            queryClient.setQueryData(\n                [\n                    resourceValue.current,\n                    'getOne',\n                    { id: String(record.id), meta: metaValue.current },\n                ],\n                oldRecord => oldRecord ?? record\n            );\n        });\n\n        onSuccessEvent(result.data);\n    }, [\n        queryClient,\n        onSuccessEvent,\n        result.data,\n        result.error,\n        result.isFetching,\n    ]);\n\n    useEffect(() => {\n        if (result.error == null || result.isFetching) return;\n        onErrorEvent(result.error);\n    }, [onErrorEvent, result.error, result.isFetching]);\n\n    useEffect(() => {\n        if (result.status === 'pending' || result.isFetching) return;\n        onSettledEvent(result.data, result.error);\n    }, [\n        onSettledEvent,\n        result.data,\n        result.error,\n        result.status,\n        result.isFetching,\n    ]);\n\n    return result;\n};\n\n/**\n * Batch all calls to a function into one single call with the arguments of all the calls.\n *\n * @example\n * let sum = 0;\n * const add = (args) => { sum = args.reduce((arg, total) => total + arg, 0); };\n * const addBatched = batch(add);\n * addBatched(2);\n * addBatched(8);\n * // add will be called once with arguments [2, 8]\n * // and sum will be equal to 10\n */\nconst batch = fn => {\n    let capturedArgs: any[] = [];\n    let timeout: ReturnType<typeof setTimeout> | null = null;\n    return (arg: any) => {\n        capturedArgs.push(arg);\n        if (timeout) clearTimeout(timeout);\n        timeout = setTimeout(() => {\n            timeout = null;\n            fn([...capturedArgs]);\n            capturedArgs = [];\n        }, 0);\n    };\n};\n\ninterface GetManyCallArgs {\n    resource: string;\n    ids: Identifier[];\n    meta?: any;\n    resolve: (data: any[]) => void;\n    reject: (error?: any) => void;\n    dataProvider: DataProvider;\n    queryClient: QueryClient;\n    signal?: AbortSignal;\n}\n\n/**\n * Group and execute all calls to the dataProvider.getMany() method for the current tick\n *\n * Thanks to batch(), this function executes at most once per tick,\n * whatever the number of calls to useGetManyAggregate().\n */\nconst callGetManyQueries = batch((calls: GetManyCallArgs[]) => {\n    const dataProvider = calls[0].dataProvider;\n    const queryClient = calls[0].queryClient;\n\n    /**\n     * Aggregate calls by resource\n     *\n     * callsByResource will look like:\n     * {\n     *     posts: [{ resource, ids, resolve, reject, dataProvider, queryClient }, ...],\n     *     tags: [{ resource, ids, resolve, reject, dataProvider, queryClient }, ...],\n     * }\n     */\n    const callsByResource = calls.reduce(\n        (acc, callArgs) => {\n            if (!acc[callArgs.resource]) {\n                acc[callArgs.resource] = [];\n            }\n            acc[callArgs.resource].push(callArgs);\n            return acc;\n        },\n        {} as { [resource: string]: GetManyCallArgs[] }\n    );\n\n    /**\n     * For each resource, aggregate ids and call dataProvider.getMany() once\n     */\n    Object.keys(callsByResource).forEach(resource => {\n        const callsForResource = callsByResource[resource];\n\n        /**\n         * Extract ids from queries, aggregate and deduplicate them\n         *\n         * @example from [[1, 2], [2, null, 3], [4, null]] to [1, 2, 3, 4]\n         */\n        const aggregatedIds = callsForResource\n            .reduce((acc, { ids }) => union(acc, ids), []) // concat + unique\n            .filter(v => v != null && v !== ''); // remove null values\n\n        const uniqueMeta = callsForResource.reduce(\n            (acc, { meta }) => meta || acc,\n            undefined\n        );\n\n        if (aggregatedIds.length === 0) {\n            // no need to call the data provider if all the ids are null\n            callsForResource.forEach(({ resolve }) => {\n                resolve([]);\n            });\n            return;\n        }\n\n        const callThatHasAllAggregatedIds = callsForResource.find(\n            ({ ids, signal }) =>\n                JSON.stringify(ids) === JSON.stringify(aggregatedIds) &&\n                !signal?.aborted\n        );\n        if (callThatHasAllAggregatedIds) {\n            // There is only one call (no aggregation), or one of the calls has the same ids as the sum of all calls.\n            // Either way, we can't trigger a new fetchQuery with the same signature, as it's already pending.\n            // Therefore, we reply with the dataProvider\n            const { dataProvider, resource, ids, meta, signal } =\n                callThatHasAllAggregatedIds;\n\n            dataProvider\n                .getMany<any>(resource, { ids, meta, signal })\n                .then(({ data }) => data)\n                .then(\n                    data => {\n                        // We must then resolve all the pending calls with the data they requested\n                        callsForResource.forEach(({ ids, resolve }) => {\n                            resolve(\n                                data.filter(record =>\n                                    ids\n                                        .map(id => String(id))\n                                        .includes(String(record.id))\n                                )\n                            );\n                        });\n                    },\n                    error => {\n                        // All pending calls must also receive the error\n                        callsForResource.forEach(({ reject }) => {\n                            reject(error);\n                        });\n                    }\n                );\n            return;\n        }\n\n        /**\n         * Call dataProvider.getMany() with the aggregatedIds,\n         * and resolve each of the promises using the results\n         */\n        queryClient\n            .fetchQuery<any[], Error, any[]>({\n                queryKey: [\n                    resource,\n                    'getMany',\n                    {\n                        ids: aggregatedIds.map(id => String(id)),\n                        meta: uniqueMeta,\n                    },\n                ],\n                queryFn: queryParams =>\n                    dataProvider\n                        .getMany<any>(resource, {\n                            ids: aggregatedIds,\n                            meta: uniqueMeta,\n                            signal:\n                                dataProvider.supportAbortSignal === true\n                                    ? queryParams.signal\n                                    : undefined,\n                        })\n                        .then(({ data }) => data),\n            })\n            .then(data => {\n                callsForResource.forEach(({ ids, resolve }) => {\n                    resolve(\n                        data.filter(record =>\n                            ids\n                                .map(id => String(id))\n                                .includes(String(record.id))\n                        )\n                    );\n                });\n            })\n            .catch(error =>\n                callsForResource.forEach(({ reject }) => reject(error))\n            );\n    });\n});\n\nconst noop = () => undefined;\n\nexport type UseGetManyAggregateOptions<RecordType extends RaRecord> = Omit<\n    UseQueryOptions<RecordType[]>,\n    'queryKey' | 'queryFn'\n> & {\n    onSuccess?: (data: RecordType[]) => void;\n    onError?: (error: Error) => void;\n    onSettled?: (data?: RecordType[], error?: Error | null) => void;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}