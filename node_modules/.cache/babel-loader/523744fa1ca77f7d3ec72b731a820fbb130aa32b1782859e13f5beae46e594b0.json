{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { useInfiniteQuery, useQueryClient } from '@tanstack/react-query';\nimport { useDataProvider } from './useDataProvider';\nimport { useEffect, useRef } from 'react';\nimport { useEvent } from '../util';\nvar MAX_DATA_LENGTH_TO_CACHE = 100;\n/**\n * Call the dataProvider.getList() method and return the resolved result\n * as well as the loading state. The return from useInfiniteGetList is equivalent to the return from react-hook form useInfiniteQuery.\n *\n * @see https://tanstack.com/query/v5/docs/react/reference/useInfiniteQuery\n *\n * This hook will return the cached result when called a second time\n * with the same parameters, until the response arrives.\n *\n * @param {string} resource The resource name, e.g. 'posts'\n * @param {Params} params The getList parameters { pagination, sort, filter, meta }\n * @param {Object} options Options object to pass to the queryClient.\n * May include side effects to be executed upon success or failure, e.g. { onSuccess: () => { fetchNextPage(); } }\n *\n * @typedef Params\n * @prop params.pagination The request pagination { page, perPage }, e.g. { page: 1, perPage: 10 }\n * @prop params.sort The request sort { field, order }, e.g. { field: 'id', order: 'DESC' }\n * @prop params.filter The request filters, e.g. { title: 'hello, world' }\n * @prop params.meta Optional meta parameters\n *\n * @returns The current request state. Destructure as { data, total, error, isPending, isSuccess, hasNextPage, fetchNextPage }.\n *\n * @example\n *\n * import { useInfiniteGetList } from 'react-admin';\n *\n * const LatestNews = () => {\n *     const { data, total, isPending, error, hasNextPage, fetchNextPage } = useInfiniteGetList(\n *         'posts',\n *         { pagination: { page: 1, perPage: 10 }, sort: { field: 'published_at', order: 'DESC' } }\n *     );\n *     if (isPending) { return <Loading />; }\n *     if (error) { return <p>ERROR</p>; }\n *     return (\n *        <>\n *            <ul>\n *                {data?.pages.map(page => {\n *                    return page.data.map(post => (\n *                        <li key={post.id}>{post.title}</li>\n *                    ));\n *                })}\n *            </ul>\n *            <div>\n *                <button disabled={!hasNextPage} onClick={() => fetchNextPage()}>\n *                    Fetch next page\n *                </button>\n *            </div>\n *        </>\n *    );\n * };\n */\nexport var useInfiniteGetList = function (resource, params, options) {\n  var _a, _b, _c;\n  if (params === void 0) {\n    params = {};\n  }\n  if (options === void 0) {\n    options = {};\n  }\n  var _d = params.pagination,\n    pagination = _d === void 0 ? {\n      page: 1,\n      perPage: 25\n    } : _d,\n    _e = params.sort,\n    sort = _e === void 0 ? {\n      field: 'id',\n      order: 'DESC'\n    } : _e,\n    _f = params.filter,\n    filter = _f === void 0 ? {} : _f,\n    meta = params.meta;\n  var dataProvider = useDataProvider();\n  var queryClient = useQueryClient();\n  var _g = options.onSuccess,\n    onSuccess = _g === void 0 ? noop : _g,\n    _h = options.onError,\n    onError = _h === void 0 ? noop : _h,\n    _j = options.onSettled,\n    onSettled = _j === void 0 ? noop : _j,\n    queryOptions = __rest(options, [\"onSuccess\", \"onError\", \"onSettled\"]);\n  var onSuccessEvent = useEvent(onSuccess);\n  var onErrorEvent = useEvent(onError);\n  var onSettledEvent = useEvent(onSettled);\n  var result = useInfiniteQuery(__assign(__assign({\n    queryKey: [resource, 'getInfiniteList', {\n      pagination: pagination,\n      sort: sort,\n      filter: filter,\n      meta: meta\n    }],\n    queryFn: function (queryParams) {\n      var _a = queryParams.pageParam,\n        pageParam = _a === void 0 ? pagination.page : _a;\n      return dataProvider.getList(resource, {\n        pagination: {\n          page: pageParam,\n          perPage: pagination.perPage\n        },\n        sort: sort,\n        filter: filter,\n        meta: meta,\n        signal: dataProvider.supportAbortSignal === true ? queryParams.signal : undefined\n      }).then(function (_a) {\n        var data = _a.data,\n          pageInfo = _a.pageInfo,\n          total = _a.total;\n        return {\n          data: data,\n          total: total,\n          pageParam: pageParam,\n          pageInfo: pageInfo\n        };\n      });\n    },\n    initialPageParam: pagination.page\n  }, queryOptions), {\n    getNextPageParam: function (lastLoadedPage) {\n      if (lastLoadedPage.pageInfo) {\n        return lastLoadedPage.pageInfo.hasNextPage ? lastLoadedPage.pageParam + 1 : undefined;\n      }\n      var totalPages = Math.ceil((lastLoadedPage.total || 0) / pagination.perPage);\n      return lastLoadedPage.pageParam < totalPages ? Number(lastLoadedPage.pageParam) + 1 : undefined;\n    },\n    getPreviousPageParam: function (lastLoadedPage) {\n      if (lastLoadedPage.pageInfo) {\n        return lastLoadedPage.pageInfo.hasPreviousPage ? lastLoadedPage.pageParam - 1 : undefined;\n      }\n      return lastLoadedPage.pageParam === 1 ? undefined : lastLoadedPage.pageParam - 1;\n    }\n  }));\n  var metaValue = useRef(meta);\n  var resourceValue = useRef(resource);\n  useEffect(function () {\n    metaValue.current = meta;\n  }, [meta]);\n  useEffect(function () {\n    resourceValue.current = resource;\n  }, [resource]);\n  useEffect(function () {\n    if (result.data === undefined || result.error != null || result.isFetching) return;\n    // optimistically populate the getOne cache\n    var allPagesDataLength = result.data.pages.reduce(function (acc, page) {\n      return acc + page.data.length;\n    }, 0);\n    if (allPagesDataLength <= MAX_DATA_LENGTH_TO_CACHE) {\n      result.data.pages.forEach(function (page) {\n        page.data.forEach(function (record) {\n          queryClient.setQueryData([resourceValue.current, 'getOne', {\n            id: String(record.id),\n            meta: metaValue.current\n          }], function (oldRecord) {\n            return oldRecord !== null && oldRecord !== void 0 ? oldRecord : record;\n          });\n        });\n      });\n    }\n    onSuccessEvent(result.data);\n  }, [onSuccessEvent, queryClient, result.data, result.error, result.isFetching]);\n  useEffect(function () {\n    if (result.error == null || result.isFetching) return;\n    onErrorEvent(result.error);\n  }, [onErrorEvent, result.error, result.isFetching]);\n  useEffect(function () {\n    if (result.status === 'pending' || result.isFetching) return;\n    onSettledEvent(result.data, result.error);\n  }, [onSettledEvent, result.data, result.error, result.status, result.isFetching]);\n  return result.data ? __assign(__assign({}, result), {\n    data: result.data,\n    total: (_c = (_b = (_a = result.data) === null || _a === void 0 ? void 0 : _a.pages[0]) === null || _b === void 0 ? void 0 : _b.total) !== null && _c !== void 0 ? _c : undefined\n  }) : result;\n};\nvar noop = function () {\n  return undefined;\n};","map":{"version":3,"names":["useInfiniteQuery","useQueryClient","useDataProvider","useEffect","useRef","useEvent","MAX_DATA_LENGTH_TO_CACHE","useInfiniteGetList","resource","params","options","_d","pagination","page","perPage","_e","sort","field","order","_f","filter","meta","dataProvider","queryClient","_g","onSuccess","noop","_h","onError","_j","onSettled","queryOptions","__rest","onSuccessEvent","onErrorEvent","onSettledEvent","result","__assign","queryKey","queryFn","queryParams","_a","pageParam","getList","signal","supportAbortSignal","undefined","then","data","pageInfo","total","initialPageParam","getNextPageParam","lastLoadedPage","hasNextPage","totalPages","Math","ceil","Number","getPreviousPageParam","hasPreviousPage","metaValue","resourceValue","current","error","isFetching","allPagesDataLength","pages","reduce","acc","length","forEach","record","setQueryData","id","String","oldRecord","status","_c","_b"],"sources":["/Users/robertbinning/Documents/GitHub/robertbinning/passkey/node_modules/react-admin/node_modules/ra-core/src/dataProvider/useInfiniteGetList.ts"],"sourcesContent":["import {\n    InfiniteData,\n    QueryKey,\n    useInfiniteQuery,\n    UseInfiniteQueryOptions,\n    UseInfiniteQueryResult,\n    useQueryClient,\n} from '@tanstack/react-query';\n\nimport { RaRecord, GetListParams, GetInfiniteListResult } from '../types';\nimport { useDataProvider } from './useDataProvider';\nimport { useEffect, useRef } from 'react';\nimport { useEvent } from '../util';\n\nconst MAX_DATA_LENGTH_TO_CACHE = 100;\n\n/**\n * Call the dataProvider.getList() method and return the resolved result\n * as well as the loading state. The return from useInfiniteGetList is equivalent to the return from react-hook form useInfiniteQuery.\n *\n * @see https://tanstack.com/query/v5/docs/react/reference/useInfiniteQuery\n *\n * This hook will return the cached result when called a second time\n * with the same parameters, until the response arrives.\n *\n * @param {string} resource The resource name, e.g. 'posts'\n * @param {Params} params The getList parameters { pagination, sort, filter, meta }\n * @param {Object} options Options object to pass to the queryClient.\n * May include side effects to be executed upon success or failure, e.g. { onSuccess: () => { fetchNextPage(); } }\n *\n * @typedef Params\n * @prop params.pagination The request pagination { page, perPage }, e.g. { page: 1, perPage: 10 }\n * @prop params.sort The request sort { field, order }, e.g. { field: 'id', order: 'DESC' }\n * @prop params.filter The request filters, e.g. { title: 'hello, world' }\n * @prop params.meta Optional meta parameters\n *\n * @returns The current request state. Destructure as { data, total, error, isPending, isSuccess, hasNextPage, fetchNextPage }.\n *\n * @example\n *\n * import { useInfiniteGetList } from 'react-admin';\n *\n * const LatestNews = () => {\n *     const { data, total, isPending, error, hasNextPage, fetchNextPage } = useInfiniteGetList(\n *         'posts',\n *         { pagination: { page: 1, perPage: 10 }, sort: { field: 'published_at', order: 'DESC' } }\n *     );\n *     if (isPending) { return <Loading />; }\n *     if (error) { return <p>ERROR</p>; }\n *     return (\n *        <>\n *            <ul>\n *                {data?.pages.map(page => {\n *                    return page.data.map(post => (\n *                        <li key={post.id}>{post.title}</li>\n *                    ));\n *                })}\n *            </ul>\n *            <div>\n *                <button disabled={!hasNextPage} onClick={() => fetchNextPage()}>\n *                    Fetch next page\n *                </button>\n *            </div>\n *        </>\n *    );\n * };\n */\n\nexport const useInfiniteGetList = <RecordType extends RaRecord = any>(\n    resource: string,\n    params: Partial<GetListParams> = {},\n    options: UseInfiniteGetListOptions<RecordType> = {}\n): UseInfiniteGetListHookValue<RecordType> => {\n    const {\n        pagination = { page: 1, perPage: 25 },\n        sort = { field: 'id', order: 'DESC' },\n        filter = {},\n        meta,\n    } = params;\n    const dataProvider = useDataProvider();\n    const queryClient = useQueryClient();\n    const {\n        onSuccess = noop,\n        onError = noop,\n        onSettled = noop,\n        ...queryOptions\n    } = options;\n    const onSuccessEvent = useEvent(onSuccess);\n    const onErrorEvent = useEvent(onError);\n    const onSettledEvent = useEvent(onSettled);\n\n    const result = useInfiniteQuery<\n        GetInfiniteListResult<RecordType>,\n        Error,\n        InfiniteData<GetInfiniteListResult<RecordType>>,\n        QueryKey,\n        number\n    >({\n        queryKey: [\n            resource,\n            'getInfiniteList',\n            { pagination, sort, filter, meta },\n        ],\n        queryFn: queryParams => {\n            const { pageParam = pagination.page } = queryParams;\n            return dataProvider\n                .getList<RecordType>(resource, {\n                    pagination: {\n                        page: pageParam,\n                        perPage: pagination.perPage,\n                    },\n                    sort,\n                    filter,\n                    meta,\n                    signal:\n                        dataProvider.supportAbortSignal === true\n                            ? queryParams.signal\n                            : undefined,\n                })\n                .then(({ data, pageInfo, total }) => ({\n                    data,\n                    total,\n                    pageParam,\n                    pageInfo,\n                }));\n        },\n        initialPageParam: pagination.page,\n        ...queryOptions,\n        getNextPageParam: lastLoadedPage => {\n            if (lastLoadedPage.pageInfo) {\n                return lastLoadedPage.pageInfo.hasNextPage\n                    ? lastLoadedPage.pageParam + 1\n                    : undefined;\n            }\n            const totalPages = Math.ceil(\n                (lastLoadedPage.total || 0) / pagination.perPage\n            );\n\n            return lastLoadedPage.pageParam < totalPages\n                ? Number(lastLoadedPage.pageParam) + 1\n                : undefined;\n        },\n        getPreviousPageParam: lastLoadedPage => {\n            if (lastLoadedPage.pageInfo) {\n                return lastLoadedPage.pageInfo.hasPreviousPage\n                    ? lastLoadedPage.pageParam - 1\n                    : undefined;\n            }\n\n            return lastLoadedPage.pageParam === 1\n                ? undefined\n                : lastLoadedPage.pageParam - 1;\n        },\n    });\n\n    const metaValue = useRef(meta);\n    const resourceValue = useRef(resource);\n\n    useEffect(() => {\n        metaValue.current = meta;\n    }, [meta]);\n\n    useEffect(() => {\n        resourceValue.current = resource;\n    }, [resource]);\n\n    useEffect(() => {\n        if (\n            result.data === undefined ||\n            result.error != null ||\n            result.isFetching\n        )\n            return;\n        // optimistically populate the getOne cache\n        const allPagesDataLength = result.data.pages.reduce(\n            (acc, page) => acc + page.data.length,\n            0\n        );\n        if (allPagesDataLength <= MAX_DATA_LENGTH_TO_CACHE) {\n            result.data.pages.forEach(page => {\n                page.data.forEach(record => {\n                    queryClient.setQueryData(\n                        [\n                            resourceValue.current,\n                            'getOne',\n                            { id: String(record.id), meta: metaValue.current },\n                        ],\n                        oldRecord => oldRecord ?? record\n                    );\n                });\n            });\n        }\n\n        onSuccessEvent(result.data);\n    }, [\n        onSuccessEvent,\n        queryClient,\n        result.data,\n        result.error,\n        result.isFetching,\n    ]);\n\n    useEffect(() => {\n        if (result.error == null || result.isFetching) return;\n        onErrorEvent(result.error);\n    }, [onErrorEvent, result.error, result.isFetching]);\n\n    useEffect(() => {\n        if (result.status === 'pending' || result.isFetching) return;\n        onSettledEvent(result.data, result.error);\n    }, [\n        onSettledEvent,\n        result.data,\n        result.error,\n        result.status,\n        result.isFetching,\n    ]);\n\n    return (\n        result.data\n            ? {\n                  ...result,\n                  data: result.data,\n                  total: result.data?.pages[0]?.total ?? undefined,\n              }\n            : result\n    ) as UseInfiniteQueryResult<\n        InfiniteData<GetInfiniteListResult<RecordType>>,\n        Error\n    > & {\n        total?: number;\n    };\n};\n\nconst noop = () => undefined;\n\nexport type UseInfiniteGetListOptions<RecordType extends RaRecord = any> = Omit<\n    UseInfiniteQueryOptions<\n        GetInfiniteListResult<RecordType>,\n        Error,\n        InfiniteData<GetInfiniteListResult<RecordType>>,\n        GetInfiniteListResult<RecordType>,\n        QueryKey,\n        number\n    >,\n    | 'queryKey'\n    | 'queryFn'\n    | 'getNextPageParam'\n    | 'getPreviousPageParam'\n    | 'initialPageParam'\n> & {\n    onSuccess?: (data: InfiniteData<GetInfiniteListResult<RecordType>>) => void;\n    onError?: (error: Error) => void;\n    onSettled?: (\n        data?: InfiniteData<GetInfiniteListResult<RecordType>>,\n        error?: Error | null\n    ) => void;\n};\n\nexport type UseInfiniteGetListHookValue<RecordType extends RaRecord = any> =\n    UseInfiniteQueryResult<InfiniteData<GetInfiniteListResult<RecordType>>> & {\n        total?: number;\n        pageParam?: number;\n    };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}