{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nimport * as React from 'react';\nimport { useFormContext } from 'react-hook-form';\nimport get from 'lodash/get';\nimport { useFormValues } from './useFormValues';\nimport { useWrappedSource } from '../core';\n/**\n * Get the current (edited) value of the record from the form and pass it\n * to a child function\n *\n * @example\n *\n * const PostEdit = () => (\n *     <Edit>\n *         <SimpleForm<FieldValues>>\n *             <BooleanInput source=\"hasEmail\" />\n *             <FormDataConsumer>\n *                 {({ formData }) => formData.hasEmail &&\n *                      <TextInput source=\"email\" />\n *                 }\n *             </FormDataConsumer>\n *         </SimpleForm>\n *     </Edit>\n * );\n *\n * @example\n *\n * const OrderEdit = () => (\n *     <Edit>\n *         <SimpleForm>\n *             <SelectInput source=\"country\" choices={countries} />\n *             <FormDataConsumer<FieldValues>>\n *                 {({ formData }) =>\n *                      <SelectInput\n *                          source=\"city\"\n *                          choices={getCitiesFor(formData.country)}\n *                      />\n *                 }\n *             </FormDataConsumer>\n *         </SimpleForm>\n *     </Edit>\n * );\n */\nvar FormDataConsumer = function (props) {\n  var form = useFormContext();\n  var\n  // Don't know exactly why, but this is needed for the form values to be updated\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  isDirty = form.formState.isDirty;\n  var formData = useFormValues();\n  return React.createElement(FormDataConsumerView, __assign({\n    formData: formData\n  }, props));\n};\nexport var FormDataConsumerView = function (props) {\n  var children = props.children,\n    formData = props.formData,\n    source = props.source;\n  var ret;\n  var finalSource = useWrappedSource(source || '');\n  // Passes an empty string here as we don't have the children sources and we just want to know if we are in an iterator\n  var matches = ArraySourceRegex.exec(finalSource);\n  // If we have an index, we are in an iterator like component (such as the SimpleFormIterator)\n  if (matches) {\n    var scopedFormData = get(formData, matches[0]);\n    ret = children({\n      formData: formData,\n      scopedFormData: scopedFormData\n    });\n  } else {\n    ret = children({\n      formData: formData\n    });\n  }\n  return ret === undefined ? null : ret;\n};\nexport default FormDataConsumer;\nvar ArraySourceRegex = new RegExp(/.+\\.\\d+$/);","map":{"version":3,"names":["React","useFormContext","get","useFormValues","useWrappedSource","FormDataConsumer","props","form","isDirty","formState","formData","createElement","FormDataConsumerView","__assign","children","source","ret","finalSource","matches","ArraySourceRegex","exec","scopedFormData","undefined","RegExp"],"sources":["/Users/robertbinning/Documents/GitHub/robertbinning/passkey/node_modules/react-admin/node_modules/ra-core/src/form/FormDataConsumer.tsx"],"sourcesContent":["import * as React from 'react';\nimport { ReactNode } from 'react';\nimport { useFormContext, FieldValues } from 'react-hook-form';\nimport get from 'lodash/get';\nimport { useFormValues } from './useFormValues';\nimport { useWrappedSource } from '../core';\n\n/**\n * Get the current (edited) value of the record from the form and pass it\n * to a child function\n *\n * @example\n *\n * const PostEdit = () => (\n *     <Edit>\n *         <SimpleForm<FieldValues>>\n *             <BooleanInput source=\"hasEmail\" />\n *             <FormDataConsumer>\n *                 {({ formData }) => formData.hasEmail &&\n *                      <TextInput source=\"email\" />\n *                 }\n *             </FormDataConsumer>\n *         </SimpleForm>\n *     </Edit>\n * );\n *\n * @example\n *\n * const OrderEdit = () => (\n *     <Edit>\n *         <SimpleForm>\n *             <SelectInput source=\"country\" choices={countries} />\n *             <FormDataConsumer<FieldValues>>\n *                 {({ formData }) =>\n *                      <SelectInput\n *                          source=\"city\"\n *                          choices={getCitiesFor(formData.country)}\n *                      />\n *                 }\n *             </FormDataConsumer>\n *         </SimpleForm>\n *     </Edit>\n * );\n */\nconst FormDataConsumer = <TFieldValues extends FieldValues = FieldValues>(\n    props: ConnectedProps<TFieldValues>\n) => {\n    const form = useFormContext<TFieldValues>();\n    const {\n        formState: {\n            // Don't know exactly why, but this is needed for the form values to be updated\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n            isDirty,\n        },\n    } = form;\n    const formData = useFormValues<TFieldValues>();\n    return (\n        <FormDataConsumerView<TFieldValues> formData={formData} {...props} />\n    );\n};\n\nexport const FormDataConsumerView = <\n    TFieldValues extends FieldValues = FieldValues,\n>(\n    props: Props<TFieldValues>\n) => {\n    const { children, formData, source } = props;\n    let ret;\n\n    const finalSource = useWrappedSource(source || '');\n\n    // Passes an empty string here as we don't have the children sources and we just want to know if we are in an iterator\n    const matches = ArraySourceRegex.exec(finalSource);\n\n    // If we have an index, we are in an iterator like component (such as the SimpleFormIterator)\n    if (matches) {\n        const scopedFormData = get(formData, matches[0]);\n        ret = children({ formData, scopedFormData });\n    } else {\n        ret = children({ formData });\n    }\n\n    return ret === undefined ? null : ret;\n};\n\nexport default FormDataConsumer;\n\nconst ArraySourceRegex = new RegExp(/.+\\.\\d+$/);\n\nexport interface FormDataConsumerRenderParams<\n    TFieldValues extends FieldValues = FieldValues,\n    TScopedFieldValues extends FieldValues = TFieldValues,\n> {\n    formData: TFieldValues;\n    scopedFormData?: TScopedFieldValues;\n}\n\nexport type FormDataConsumerRender<\n    TFieldValues extends FieldValues = FieldValues,\n> = (params: FormDataConsumerRenderParams<TFieldValues>) => ReactNode;\n\ninterface ConnectedProps<TFieldValues extends FieldValues = FieldValues> {\n    children: FormDataConsumerRender<TFieldValues>;\n    form?: string;\n    record?: any;\n    source?: string;\n    [key: string]: any;\n}\n\ninterface Props<TFieldValues extends FieldValues> extends ConnectedProps {\n    formData: TFieldValues;\n    index?: number;\n}\n"],"mappings":";;;;;;;;;;AAAA,OAAO,KAAKA,KAAK,MAAM,OAAO;AAE9B,SAASC,cAAc,QAAqB,iBAAiB;AAC7D,OAAOC,GAAG,MAAM,YAAY;AAC5B,SAASC,aAAa,QAAQ,iBAAiB;AAC/C,SAASC,gBAAgB,QAAQ,SAAS;AAE1C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqCA,IAAMC,gBAAgB,GAAG,SAAAA,CACrBC,KAAmC;EAEnC,IAAMC,IAAI,GAAGN,cAAc,EAAgB;EAKnC;EAFA;EACA;EACAO,OAAO,GAEXD,IAAI,CAAAE,SAAA,CAAAD,OAFO;EAGf,IAAME,QAAQ,GAAGP,aAAa,EAAgB;EAC9C,OACIH,KAAA,CAAAW,aAAA,CAACC,oBAAoB,EAAAC,QAAA;IAAeH,QAAQ,EAAEA;EAAQ,GAAMJ,KAAK,EAAI;AAE7E,CAAC;AAED,OAAO,IAAMM,oBAAoB,GAAG,SAAAA,CAGhCN,KAA0B;EAElB,IAAAQ,QAAQ,GAAuBR,KAAK,CAAAQ,QAA5B;IAAEJ,QAAQ,GAAaJ,KAAK,CAAAI,QAAlB;IAAEK,MAAM,GAAKT,KAAK,CAAAS,MAAV;EAClC,IAAIC,GAAG;EAEP,IAAMC,WAAW,GAAGb,gBAAgB,CAACW,MAAM,IAAI,EAAE,CAAC;EAElD;EACA,IAAMG,OAAO,GAAGC,gBAAgB,CAACC,IAAI,CAACH,WAAW,CAAC;EAElD;EACA,IAAIC,OAAO,EAAE;IACT,IAAMG,cAAc,GAAGnB,GAAG,CAACQ,QAAQ,EAAEQ,OAAO,CAAC,CAAC,CAAC,CAAC;IAChDF,GAAG,GAAGF,QAAQ,CAAC;MAAEJ,QAAQ,EAAAA,QAAA;MAAEW,cAAc,EAAAA;IAAA,CAAE,CAAC;GAC/C,MAAM;IACHL,GAAG,GAAGF,QAAQ,CAAC;MAAEJ,QAAQ,EAAAA;IAAA,CAAE,CAAC;;EAGhC,OAAOM,GAAG,KAAKM,SAAS,GAAG,IAAI,GAAGN,GAAG;AACzC,CAAC;AAED,eAAeX,gBAAgB;AAE/B,IAAMc,gBAAgB,GAAG,IAAII,MAAM,CAAC,UAAU,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}