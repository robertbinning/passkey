{"ast":null,"code":"var __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { useState, useMemo } from 'react';\nimport set from 'lodash/set';\nimport get from 'lodash/get';\nimport cloneDeep from 'lodash/cloneDeep';\nimport { useLocaleState } from './useLocaleState';\n/**\n * Hook supplying the logic to translate a field value in multiple languages.\n *\n * @param options The hook options\n * @param {string} options.defaultLocale The locale of the default selected locale. Defaults to 'en'.\n * @param {string[]} options.locales An array of the supported locales. Each is an object with a locale and a name property. For example { locale: 'en', name: 'English' }.\n *\n * @returns\n * An object with following properties and methods:\n * - selectedLocale: The locale of the currently selected locale\n * - locales: An array of the supported locales\n * - getLabel: A function which returns the translated label for the given field\n * - getSource: A function which returns the source for the given field\n * - selectLocale: A function which set the selected locale\n */\nexport var useTranslatable = function (options) {\n  var localeFromUI = useLocaleState()[0];\n  var _a = options.defaultLocale,\n    defaultLocale = _a === void 0 ? localeFromUI : _a,\n    locales = options.locales;\n  var _b = useState(defaultLocale),\n    selectedLocale = _b[0],\n    setSelectedLocale = _b[1];\n  var context = useMemo(function () {\n    return {\n      locales: locales,\n      selectedLocale: selectedLocale,\n      selectLocale: setSelectedLocale,\n      getRecordForLocale: getRecordForLocale\n    };\n  }, [locales, selectedLocale]);\n  return context;\n};\n/**\n * Returns a record where translatable fields have their values set to the value of the given locale.\n * This is necessary because the fields rely on the RecordContext to get their values and have no knowledge of the locale.\n *\n * Given the record { title: { en: 'title_en', fr: 'title_fr' } } and the locale 'fr',\n * the record for the locale 'fr' will be { title: 'title_fr' }\n */\nexport var getRecordForLocale = function (record, locale) {\n  if (!record) {\n    return record;\n  }\n  // Get all paths of the record\n  var paths = getRecordPaths(record);\n  // For each path, if a path ends with the locale, set the value of the path without the locale\n  // to the value of the path with the locale\n  var recordForLocale = paths.reduce(function (acc, path) {\n    if (path.includes(locale)) {\n      var pathWithoutLocale = path.slice(0, -1);\n      var value = get(record, path);\n      return set(acc, pathWithoutLocale, value);\n    }\n    return acc;\n  }, cloneDeep(record));\n  return recordForLocale;\n};\n// Return all the possible paths of the record as an array of arrays\n// For example, given the record\n//     {\n//         title: { en: 'title_en', fr: 'title_fr' },\n//         items: [\n//             { description: { en: 'item1_en', fr: 'item1_fr' } },\n//             { description: { en: 'item2_en', fr: 'item2_fr' } }\n//         ]\n//     },\n// the paths will be\n//     [\n//         ['title'],\n//         ['title', 'en'],\n//         ['title', 'fr'],\n//         ['items'],\n//         ['items', '0'],\n//         ['items', '0', 'description'],\n//         ['items', '0', 'description', 'en'],\n//         ['items', '0', 'description', 'fr'],\n//         ['items', '1'],\n//         ['items', '1', 'description'],\n//         ['items', '1', 'description', 'en'],\n//         ['items', '1', 'description', 'fr']]\nvar getRecordPaths = function (record, path) {\n  if (record === void 0) {\n    record = {};\n  }\n  if (path === void 0) {\n    path = [];\n  }\n  return Object.entries(record).reduce(function (acc, _a) {\n    var key = _a[0],\n      value = _a[1];\n    if (typeof value === 'object') {\n      return __spreadArray(__spreadArray(__spreadArray([], acc, true), [__spreadArray(__spreadArray([], path, true), [key], false)], false), getRecordPaths(value, __spreadArray(__spreadArray([], path, true), [key], false)), true);\n    }\n    if (Array.isArray(value)) {\n      return value.reduce(function (acc, item, index) {\n        return __spreadArray(__spreadArray([], acc, true), getRecordPaths(item, __spreadArray(__spreadArray([], path, true), [key, \"\".concat(index)], false)), true);\n      }, acc);\n    }\n    return __spreadArray(__spreadArray([], acc, true), [__spreadArray(__spreadArray([], path, true), [key], false)], false);\n  }, []);\n};","map":{"version":3,"names":["useState","useMemo","set","get","cloneDeep","useLocaleState","useTranslatable","options","localeFromUI","_a","defaultLocale","locales","_b","selectedLocale","setSelectedLocale","context","selectLocale","getRecordForLocale","record","locale","paths","getRecordPaths","recordForLocale","reduce","acc","path","includes","pathWithoutLocale","slice","value","Object","entries","key","__spreadArray","Array","isArray","item","index","concat"],"sources":["/Users/robertbinning/Documents/GitHub/robertbinning/passkey/node_modules/react-admin/node_modules/ra-core/src/i18n/useTranslatable.ts"],"sourcesContent":["import { useState, useMemo } from 'react';\nimport set from 'lodash/set';\nimport get from 'lodash/get';\nimport cloneDeep from 'lodash/cloneDeep';\nimport { TranslatableContextValue } from './TranslatableContext';\nimport { useLocaleState } from './useLocaleState';\n\n/**\n * Hook supplying the logic to translate a field value in multiple languages.\n *\n * @param options The hook options\n * @param {string} options.defaultLocale The locale of the default selected locale. Defaults to 'en'.\n * @param {string[]} options.locales An array of the supported locales. Each is an object with a locale and a name property. For example { locale: 'en', name: 'English' }.\n *\n * @returns\n * An object with following properties and methods:\n * - selectedLocale: The locale of the currently selected locale\n * - locales: An array of the supported locales\n * - getLabel: A function which returns the translated label for the given field\n * - getSource: A function which returns the source for the given field\n * - selectLocale: A function which set the selected locale\n */\nexport const useTranslatable = (\n    options: UseTranslatableOptions\n): TranslatableContextValue => {\n    const [localeFromUI] = useLocaleState();\n    const { defaultLocale = localeFromUI, locales } = options;\n    const [selectedLocale, setSelectedLocale] = useState(defaultLocale);\n\n    const context = useMemo<TranslatableContextValue>(\n        () => ({\n            locales,\n            selectedLocale,\n            selectLocale: setSelectedLocale,\n            getRecordForLocale,\n        }),\n        [locales, selectedLocale]\n    );\n\n    return context;\n};\n\nexport type UseTranslatableOptions = {\n    defaultLocale?: string;\n    locales: string[];\n};\n\n/**\n * Returns a record where translatable fields have their values set to the value of the given locale.\n * This is necessary because the fields rely on the RecordContext to get their values and have no knowledge of the locale.\n *\n * Given the record { title: { en: 'title_en', fr: 'title_fr' } } and the locale 'fr',\n * the record for the locale 'fr' will be { title: 'title_fr' }\n */\nexport const getRecordForLocale = (record: {} | undefined, locale: string) => {\n    if (!record) {\n        return record;\n    }\n    // Get all paths of the record\n    const paths = getRecordPaths(record);\n\n    // For each path, if a path ends with the locale, set the value of the path without the locale\n    // to the value of the path with the locale\n    const recordForLocale = paths.reduce((acc, path) => {\n        if (path.includes(locale)) {\n            const pathWithoutLocale = path.slice(0, -1);\n            const value = get(record, path);\n            return set(acc, pathWithoutLocale, value);\n        }\n        return acc;\n    }, cloneDeep(record));\n\n    return recordForLocale;\n};\n\n// Return all the possible paths of the record as an array of arrays\n// For example, given the record\n//     {\n//         title: { en: 'title_en', fr: 'title_fr' },\n//         items: [\n//             { description: { en: 'item1_en', fr: 'item1_fr' } },\n//             { description: { en: 'item2_en', fr: 'item2_fr' } }\n//         ]\n//     },\n// the paths will be\n//     [\n//         ['title'],\n//         ['title', 'en'],\n//         ['title', 'fr'],\n//         ['items'],\n//         ['items', '0'],\n//         ['items', '0', 'description'],\n//         ['items', '0', 'description', 'en'],\n//         ['items', '0', 'description', 'fr'],\n//         ['items', '1'],\n//         ['items', '1', 'description'],\n//         ['items', '1', 'description', 'en'],\n//         ['items', '1', 'description', 'fr']]\nconst getRecordPaths = (\n    record: any = {},\n    path: Array<string> = []\n): Array<Array<string>> => {\n    return Object.entries(record).reduce((acc, [key, value]) => {\n        if (typeof value === 'object') {\n            return [\n                ...acc,\n                [...path, key],\n                ...getRecordPaths(value, [...path, key]),\n            ];\n        }\n        if (Array.isArray(value)) {\n            return value.reduce(\n                (acc, item, index) => [\n                    ...acc,\n                    ...getRecordPaths(item, [...path, key, `${index}`]),\n                ],\n                acc\n            );\n        }\n        return [...acc, [...path, key]];\n    }, []);\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}