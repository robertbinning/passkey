{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { useMemo, useRef } from 'react';\nimport { useMutation, useQueryClient } from '@tanstack/react-query';\nimport { useDataProvider } from './useDataProvider';\nimport { useEvent } from '../util';\n/**\n * Get a callback to call the dataProvider.create() method, the result and the loading state.\n *\n * @param {string} resource\n * @param {Params} params The create parameters { data }\n * @param {Object} options Options object to pass to the queryClient.\n * May include side effects to be executed upon success or failure, e.g. { onSuccess: () => { refresh(); } }\n *\n * @typedef Params\n * @prop params.data The record to create, e.g. { title: 'hello, world' }\n *\n * @returns The current mutation state. Destructure as [create, { data, error, isPending }].\n *\n * The return value updates according to the request state:\n *\n * - initial: [create, { isPending: false, isIdle: true }]\n * - start:   [create, { isPending: true }]\n * - success: [create, { data: [data from response], isPending: false, isSuccess: true }]\n * - error:   [create, { error: [error from response], isPending: false, isError: true }]\n *\n * The create() function must be called with a resource and a parameter object: create(resource, { data, meta }, options)\n *\n * This hook uses react-query useMutation under the hood.\n * This means the state object contains mutate, isIdle, reset and other react-query methods.\n *\n * @see https://tanstack.com/query/v5/docs/react/reference/useMutation\n *\n * @example // set params when calling the create callback\n *\n * import { useCreate, useRecordContext } from 'react-admin';\n *\n * const LikeButton = () => {\n *     const record = useRecordContext();\n *     const like = { postId: record.id };\n *     const [create, { isPending, error }] = useCreate();\n *     const handleClick = () => {\n *         create('likes', { data: like })\n *     }\n *     if (error) { return <p>ERROR</p>; }\n *     return <button disabled={isPending} onClick={handleClick}>Like</button>;\n * };\n *\n * @example // set params when calling the hook\n *\n * import { useCreate, useRecordContext } from 'react-admin';\n *\n * const LikeButton = () => {\n *     const record = useRecordContext();\n *     const like = { postId: record.id };\n *     const [create, { isPending, error }] = useCreate('likes', { data: like });\n *     if (error) { return <p>ERROR</p>; }\n *     return <button disabled={isPending} onClick={() => create()}>Like</button>;\n * };\n *\n * @example // TypeScript\n * const [create, { data }] = useCreate<Product>('products', { data: product });\n *                    \\-- data is Product\n */\nexport var useCreate = function (resource, params, options) {\n  if (params === void 0) {\n    params = {};\n  }\n  if (options === void 0) {\n    options = {};\n  }\n  var dataProvider = useDataProvider();\n  var queryClient = useQueryClient();\n  var paramsRef = useRef(params);\n  var hasCallTimeOnError = useRef(false);\n  var hasCallTimeOnSuccess = useRef(false);\n  var hasCallTimeOnSettled = useRef(false);\n  var getMutateWithMiddlewares = options.getMutateWithMiddlewares,\n    mutationOptions = __rest(options, [\"getMutateWithMiddlewares\"]);\n  var mutation = useMutation(__assign(__assign({\n    mutationFn: function (_a) {\n      var _b = _a === void 0 ? {} : _a,\n        _c = _b.resource,\n        callTimeResource = _c === void 0 ? resource : _c,\n        _d = _b.data,\n        callTimeData = _d === void 0 ? paramsRef.current.data : _d,\n        _e = _b.meta,\n        callTimeMeta = _e === void 0 ? paramsRef.current.meta : _e;\n      if (!callTimeResource) {\n        throw new Error('useCreate mutation requires a non-empty resource');\n      }\n      if (!callTimeData) {\n        throw new Error('useCreate mutation requires a non-empty data object');\n      }\n      if (getMutateWithMiddlewares) {\n        var createWithMiddlewares = getMutateWithMiddlewares(dataProvider.create.bind(dataProvider));\n        return createWithMiddlewares(callTimeResource, {\n          data: callTimeData,\n          meta: callTimeMeta\n        }).then(function (_a) {\n          var data = _a.data;\n          return data;\n        });\n      }\n      return dataProvider.create(callTimeResource, {\n        data: callTimeData,\n        meta: callTimeMeta\n      }).then(function (_a) {\n        var data = _a.data;\n        return data;\n      });\n    }\n  }, mutationOptions), {\n    onError: function (error, variables, context) {\n      if (options.onError && !hasCallTimeOnError.current) {\n        return options.onError(error, variables, context);\n      }\n    },\n    onSuccess: function (data, variables, context) {\n      if (variables === void 0) {\n        variables = {};\n      }\n      var _a = variables.resource,\n        callTimeResource = _a === void 0 ? resource : _a;\n      queryClient.setQueryData([callTimeResource, 'getOne', {\n        id: String(data.id)\n      }], data);\n      queryClient.invalidateQueries({\n        queryKey: [callTimeResource, 'getList']\n      });\n      queryClient.invalidateQueries({\n        queryKey: [callTimeResource, 'getInfiniteList']\n      });\n      queryClient.invalidateQueries({\n        queryKey: [callTimeResource, 'getMany']\n      });\n      queryClient.invalidateQueries({\n        queryKey: [callTimeResource, 'getManyReference']\n      });\n      if (options.onSuccess && !hasCallTimeOnSuccess.current) {\n        options.onSuccess(data, variables, context);\n      }\n    },\n    onSettled: function (data, error, variables, context) {\n      if (options.onSettled && !hasCallTimeOnSettled.current) {\n        return options.onSettled(data, error, variables, context);\n      }\n    }\n  }));\n  var create = function (callTimeResource, callTimeParams, callTimeOptions) {\n    if (callTimeResource === void 0) {\n      callTimeResource = resource;\n    }\n    if (callTimeParams === void 0) {\n      callTimeParams = {};\n    }\n    if (callTimeOptions === void 0) {\n      callTimeOptions = {};\n    }\n    var _a = callTimeOptions.returnPromise,\n      returnPromise = _a === void 0 ? options.returnPromise : _a,\n      otherCallTimeOptions = __rest(callTimeOptions, [\"returnPromise\"]);\n    hasCallTimeOnError.current = !!otherCallTimeOptions.onError;\n    hasCallTimeOnSuccess.current = !!otherCallTimeOptions.onSuccess;\n    hasCallTimeOnSettled.current = !!otherCallTimeOptions.onSettled;\n    if (returnPromise) {\n      return mutation.mutateAsync(__assign({\n        resource: callTimeResource\n      }, callTimeParams), otherCallTimeOptions);\n    }\n    return mutation.mutate(__assign({\n      resource: callTimeResource\n    }, callTimeParams), otherCallTimeOptions);\n  };\n  var mutationResult = useMemo(function () {\n    return __assign({\n      isLoading: mutation.isPending\n    }, mutation);\n  }, [mutation]);\n  return [useEvent(create), mutationResult];\n};","map":{"version":3,"names":["useMemo","useRef","useMutation","useQueryClient","useDataProvider","useEvent","useCreate","resource","params","options","dataProvider","queryClient","paramsRef","hasCallTimeOnError","hasCallTimeOnSuccess","hasCallTimeOnSettled","getMutateWithMiddlewares","mutationOptions","__rest","mutation","__assign","mutationFn","_a","_b","_c","callTimeResource","_d","data","callTimeData","current","_e","meta","callTimeMeta","Error","createWithMiddlewares","create","bind","then","onError","error","variables","context","onSuccess","setQueryData","id","String","invalidateQueries","queryKey","onSettled","callTimeParams","callTimeOptions","returnPromise","otherCallTimeOptions","mutateAsync","mutate","mutationResult","isLoading","isPending"],"sources":["/Users/robertbinning/Documents/GitHub/robertbinning/passkey/node_modules/react-admin/node_modules/ra-core/src/dataProvider/useCreate.ts"],"sourcesContent":["import { useMemo, useRef } from 'react';\nimport {\n    useMutation,\n    UseMutationOptions,\n    UseMutationResult,\n    useQueryClient,\n    MutateOptions,\n} from '@tanstack/react-query';\n\nimport { useDataProvider } from './useDataProvider';\nimport { RaRecord, CreateParams, Identifier, DataProvider } from '../types';\nimport { useEvent } from '../util';\n\n/**\n * Get a callback to call the dataProvider.create() method, the result and the loading state.\n *\n * @param {string} resource\n * @param {Params} params The create parameters { data }\n * @param {Object} options Options object to pass to the queryClient.\n * May include side effects to be executed upon success or failure, e.g. { onSuccess: () => { refresh(); } }\n *\n * @typedef Params\n * @prop params.data The record to create, e.g. { title: 'hello, world' }\n *\n * @returns The current mutation state. Destructure as [create, { data, error, isPending }].\n *\n * The return value updates according to the request state:\n *\n * - initial: [create, { isPending: false, isIdle: true }]\n * - start:   [create, { isPending: true }]\n * - success: [create, { data: [data from response], isPending: false, isSuccess: true }]\n * - error:   [create, { error: [error from response], isPending: false, isError: true }]\n *\n * The create() function must be called with a resource and a parameter object: create(resource, { data, meta }, options)\n *\n * This hook uses react-query useMutation under the hood.\n * This means the state object contains mutate, isIdle, reset and other react-query methods.\n *\n * @see https://tanstack.com/query/v5/docs/react/reference/useMutation\n *\n * @example // set params when calling the create callback\n *\n * import { useCreate, useRecordContext } from 'react-admin';\n *\n * const LikeButton = () => {\n *     const record = useRecordContext();\n *     const like = { postId: record.id };\n *     const [create, { isPending, error }] = useCreate();\n *     const handleClick = () => {\n *         create('likes', { data: like })\n *     }\n *     if (error) { return <p>ERROR</p>; }\n *     return <button disabled={isPending} onClick={handleClick}>Like</button>;\n * };\n *\n * @example // set params when calling the hook\n *\n * import { useCreate, useRecordContext } from 'react-admin';\n *\n * const LikeButton = () => {\n *     const record = useRecordContext();\n *     const like = { postId: record.id };\n *     const [create, { isPending, error }] = useCreate('likes', { data: like });\n *     if (error) { return <p>ERROR</p>; }\n *     return <button disabled={isPending} onClick={() => create()}>Like</button>;\n * };\n *\n * @example // TypeScript\n * const [create, { data }] = useCreate<Product>('products', { data: product });\n *                    \\-- data is Product\n */\nexport const useCreate = <\n    RecordType extends Omit<RaRecord, 'id'> = any,\n    MutationError = unknown,\n    ResultRecordType extends RaRecord = RecordType & { id: Identifier },\n>(\n    resource?: string,\n    params: Partial<CreateParams<Partial<RecordType>>> = {},\n    options: UseCreateOptions<RecordType, MutationError, ResultRecordType> = {}\n): UseCreateResult<RecordType, boolean, MutationError, ResultRecordType> => {\n    const dataProvider = useDataProvider();\n    const queryClient = useQueryClient();\n    const paramsRef =\n        useRef<Partial<CreateParams<Partial<RecordType>>>>(params);\n    const hasCallTimeOnError = useRef(false);\n    const hasCallTimeOnSuccess = useRef(false);\n    const hasCallTimeOnSettled = useRef(false);\n    const { getMutateWithMiddlewares, ...mutationOptions } = options;\n    const mutation = useMutation<\n        ResultRecordType,\n        MutationError,\n        Partial<UseCreateMutateParams<RecordType>>\n    >({\n        mutationFn: ({\n            resource: callTimeResource = resource,\n            data: callTimeData = paramsRef.current.data,\n            meta: callTimeMeta = paramsRef.current.meta,\n        } = {}) => {\n            if (!callTimeResource) {\n                throw new Error(\n                    'useCreate mutation requires a non-empty resource'\n                );\n            }\n            if (!callTimeData) {\n                throw new Error(\n                    'useCreate mutation requires a non-empty data object'\n                );\n            }\n            if (getMutateWithMiddlewares) {\n                const createWithMiddlewares = getMutateWithMiddlewares(\n                    dataProvider.create.bind(dataProvider)\n                );\n                return createWithMiddlewares(callTimeResource, {\n                    data: callTimeData,\n                    meta: callTimeMeta,\n                }).then(({ data }) => data);\n            }\n            return dataProvider\n                .create<RecordType, ResultRecordType>(callTimeResource, {\n                    data: callTimeData,\n                    meta: callTimeMeta,\n                })\n                .then(({ data }) => data);\n        },\n        ...mutationOptions,\n        onError: (error, variables, context) => {\n            if (options.onError && !hasCallTimeOnError.current) {\n                return options.onError(error, variables, context);\n            }\n        },\n        onSuccess: (\n            data: ResultRecordType,\n            variables: Partial<UseCreateMutateParams<RecordType>> = {},\n            context: unknown\n        ) => {\n            const { resource: callTimeResource = resource } = variables;\n            queryClient.setQueryData(\n                [callTimeResource, 'getOne', { id: String(data.id) }],\n                data\n            );\n            queryClient.invalidateQueries({\n                queryKey: [callTimeResource, 'getList'],\n            });\n            queryClient.invalidateQueries({\n                queryKey: [callTimeResource, 'getInfiniteList'],\n            });\n            queryClient.invalidateQueries({\n                queryKey: [callTimeResource, 'getMany'],\n            });\n            queryClient.invalidateQueries({\n                queryKey: [callTimeResource, 'getManyReference'],\n            });\n\n            if (options.onSuccess && !hasCallTimeOnSuccess.current) {\n                options.onSuccess(data, variables, context);\n            }\n        },\n        onSettled: (data, error, variables, context) => {\n            if (options.onSettled && !hasCallTimeOnSettled.current) {\n                return options.onSettled(data, error, variables, context);\n            }\n        },\n    });\n\n    const create = (\n        callTimeResource: string | undefined = resource,\n        callTimeParams: Partial<CreateParams<Partial<RecordType>>> = {},\n        callTimeOptions: MutateOptions<\n            ResultRecordType,\n            MutationError,\n            Partial<UseCreateMutateParams<RecordType>>,\n            unknown\n        > & { returnPromise?: boolean } = {}\n    ) => {\n        const {\n            returnPromise = options.returnPromise,\n            ...otherCallTimeOptions\n        } = callTimeOptions;\n\n        hasCallTimeOnError.current = !!otherCallTimeOptions.onError;\n        hasCallTimeOnSuccess.current = !!otherCallTimeOptions.onSuccess;\n        hasCallTimeOnSettled.current = !!otherCallTimeOptions.onSettled;\n\n        if (returnPromise) {\n            return mutation.mutateAsync(\n                { resource: callTimeResource, ...callTimeParams },\n                otherCallTimeOptions\n            );\n        }\n        return mutation.mutate(\n            { resource: callTimeResource, ...callTimeParams },\n            otherCallTimeOptions\n        );\n    };\n\n    const mutationResult = useMemo(\n        () => ({\n            isLoading: mutation.isPending,\n            ...mutation,\n        }),\n        [mutation]\n    );\n\n    return [useEvent(create), mutationResult];\n};\n\nexport interface UseCreateMutateParams<\n    RecordType extends Omit<RaRecord, 'id'> = any,\n> {\n    resource?: string;\n    data?: Partial<Omit<RecordType, 'id'>>;\n    meta?: any;\n}\n\nexport type UseCreateOptions<\n    RecordType extends Omit<RaRecord, 'id'> = any,\n    MutationError = unknown,\n    ResultRecordType extends RaRecord = RecordType & { id: Identifier },\n> = Omit<\n    UseMutationOptions<\n        ResultRecordType,\n        MutationError,\n        Partial<UseCreateMutateParams<RecordType>>\n    >,\n    'mutationFn'\n> & {\n    returnPromise?: boolean;\n    getMutateWithMiddlewares?: <\n        CreateFunctionType extends\n            DataProvider['create'] = DataProvider['create'],\n    >(\n        mutate: CreateFunctionType\n    ) => (\n        ...Params: Parameters<CreateFunctionType>\n    ) => ReturnType<CreateFunctionType>;\n};\n\nexport type CreateMutationFunction<\n    RecordType extends Omit<RaRecord, 'id'> = any,\n    TReturnPromise extends boolean = boolean,\n    MutationError = unknown,\n    ResultRecordType extends RaRecord = RecordType & { id: Identifier },\n> = (\n    resource?: string,\n    params?: Partial<CreateParams<Partial<RecordType>>>,\n    options?: MutateOptions<\n        ResultRecordType,\n        MutationError,\n        Partial<UseCreateMutateParams<RecordType>>,\n        unknown\n    > & { returnPromise?: TReturnPromise }\n) => TReturnPromise extends true ? Promise<ResultRecordType> : void;\n\nexport type UseCreateResult<\n    RecordType extends Omit<RaRecord, 'id'> = any,\n    TReturnPromise extends boolean = boolean,\n    MutationError = unknown,\n    ResultRecordType extends RaRecord = RecordType & { id: Identifier },\n> = [\n    CreateMutationFunction<\n        RecordType,\n        TReturnPromise,\n        MutationError,\n        ResultRecordType\n    >,\n    UseMutationResult<\n        ResultRecordType,\n        MutationError,\n        Partial<UseCreateMutateParams<RecordType>>,\n        unknown\n    >,\n];\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}