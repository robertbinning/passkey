{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { useQuery } from '@tanstack/react-query';\nimport { useDataProvider } from './useDataProvider';\nimport { useEffect } from 'react';\nimport { useEvent } from '../util';\n/**\n * Call the dataProvider.getOne() method and return the resolved value\n * as well as the loading state.\n *\n * The return value updates according to the request state:\n *\n * - start: { isPending: true, isFetching: true, refetch }\n * - success: { data: [data from response], isPending: false, refetch }\n * - error: { error: [error from response], isPending: false, refetch }\n *\n * This hook will return the cached result when called a second time\n * with the same parameters, until the response arrives.\n *\n * @param resource The resource name, e.g. 'posts'\n * @param {Params} params The getOne parameters { id, meta }, e.g. { id: 123 }\n * @param {Options} options Options object to pass to the react-query queryClient.\n *\n * @typedef Params\n * @prop id a resource identifier, e.g. 123\n *\n * @typedef Options\n * @prop enabled Flag to conditionally run the query. If it's false, the query will not run\n * @prop onSuccess Side effect function to be executed upon success, e.g. { onSuccess: { refresh: true } }\n * @prop onError Side effect function to be executed upon failure, e.g. { onError: error => notify(error.message) }\n *\n * @returns The current request state. Destructure as { data, error, isPending, refetch }.\n *\n * @example\n *\n * import { useGetOne, useRecordContext } from 'react-admin';\n *\n * const UserProfile = () => {\n *     const record = useRecordContext();\n *     const { data, isPending, error } = useGetOne('users', { id: record.id });\n *     if (isPending) { return <Loading />; }\n *     if (error) { return <p>ERROR</p>; }\n *     return <div>User {data.username}</div>;\n * };\n */\nexport var useGetOne = function (resource, _a, options) {\n  var id = _a.id,\n    meta = _a.meta;\n  if (options === void 0) {\n    options = {};\n  }\n  var dataProvider = useDataProvider();\n  var _b = options.onError,\n    onError = _b === void 0 ? noop : _b,\n    _c = options.onSuccess,\n    onSuccess = _c === void 0 ? noop : _c,\n    _d = options.onSettled,\n    onSettled = _d === void 0 ? noop : _d,\n    queryOptions = __rest(options, [\"onError\", \"onSuccess\", \"onSettled\"]);\n  var onSuccessEvent = useEvent(onSuccess);\n  var onErrorEvent = useEvent(onError);\n  var onSettledEvent = useEvent(onSettled);\n  var result = useQuery(__assign({\n    // Sometimes the id comes as a string (e.g. when read from the URL in a Show view).\n    // Sometimes the id comes as a number (e.g. when read from a Record in useGetList response).\n    // As the react-query cache is type-sensitive, we always stringify the identifier to get a match\n    queryKey: [resource, 'getOne', {\n      id: String(id),\n      meta: meta\n    }],\n    queryFn: function (queryParams) {\n      return dataProvider.getOne(resource, {\n        id: id,\n        meta: meta,\n        signal: dataProvider.supportAbortSignal === true ? queryParams.signal : undefined\n      }).then(function (_a) {\n        var data = _a.data;\n        return data;\n      });\n    }\n  }, queryOptions));\n  useEffect(function () {\n    if (result.data === undefined || result.error != null || result.isFetching) return;\n    onSuccessEvent(result.data);\n  }, [onSuccessEvent, result.data, result.error, result.isFetching]);\n  useEffect(function () {\n    if (result.error == null || result.isFetching) return;\n    onErrorEvent(result.error);\n  }, [onErrorEvent, result.error, result.isFetching]);\n  useEffect(function () {\n    if (result.status === 'pending' || result.isFetching) return;\n    onSettledEvent(result.data, result.error);\n  }, [onSettledEvent, result.data, result.error, result.status, result.isFetching]);\n  return result;\n};\nvar noop = function () {\n  return undefined;\n};","map":{"version":3,"names":["useQuery","useDataProvider","useEffect","useEvent","useGetOne","resource","_a","options","id","meta","dataProvider","_b","onError","noop","_c","onSuccess","_d","onSettled","queryOptions","__rest","onSuccessEvent","onErrorEvent","onSettledEvent","result","__assign","queryKey","String","queryFn","queryParams","getOne","signal","supportAbortSignal","undefined","then","data","error","isFetching","status"],"sources":["/Users/robertbinning/Documents/GitHub/robertbinning/passkey/node_modules/react-admin/node_modules/ra-core/src/dataProvider/useGetOne.ts"],"sourcesContent":["import { RaRecord, GetOneParams, GetOneResult } from '../types';\nimport {\n    useQuery,\n    UseQueryOptions,\n    UseQueryResult,\n} from '@tanstack/react-query';\nimport { useDataProvider } from './useDataProvider';\nimport { useEffect } from 'react';\nimport { useEvent } from '../util';\n\n/**\n * Call the dataProvider.getOne() method and return the resolved value\n * as well as the loading state.\n *\n * The return value updates according to the request state:\n *\n * - start: { isPending: true, isFetching: true, refetch }\n * - success: { data: [data from response], isPending: false, refetch }\n * - error: { error: [error from response], isPending: false, refetch }\n *\n * This hook will return the cached result when called a second time\n * with the same parameters, until the response arrives.\n *\n * @param resource The resource name, e.g. 'posts'\n * @param {Params} params The getOne parameters { id, meta }, e.g. { id: 123 }\n * @param {Options} options Options object to pass to the react-query queryClient.\n *\n * @typedef Params\n * @prop id a resource identifier, e.g. 123\n *\n * @typedef Options\n * @prop enabled Flag to conditionally run the query. If it's false, the query will not run\n * @prop onSuccess Side effect function to be executed upon success, e.g. { onSuccess: { refresh: true } }\n * @prop onError Side effect function to be executed upon failure, e.g. { onError: error => notify(error.message) }\n *\n * @returns The current request state. Destructure as { data, error, isPending, refetch }.\n *\n * @example\n *\n * import { useGetOne, useRecordContext } from 'react-admin';\n *\n * const UserProfile = () => {\n *     const record = useRecordContext();\n *     const { data, isPending, error } = useGetOne('users', { id: record.id });\n *     if (isPending) { return <Loading />; }\n *     if (error) { return <p>ERROR</p>; }\n *     return <div>User {data.username}</div>;\n * };\n */\nexport const useGetOne = <RecordType extends RaRecord = any>(\n    resource: string,\n    { id, meta }: GetOneParams<RecordType>,\n    options: UseGetOneOptions<RecordType> = {}\n): UseGetOneHookValue<RecordType> => {\n    const dataProvider = useDataProvider();\n    const {\n        onError = noop,\n        onSuccess = noop,\n        onSettled = noop,\n        ...queryOptions\n    } = options;\n    const onSuccessEvent = useEvent(onSuccess);\n    const onErrorEvent = useEvent(onError);\n    const onSettledEvent = useEvent(onSettled);\n\n    const result = useQuery<RecordType>({\n        // Sometimes the id comes as a string (e.g. when read from the URL in a Show view).\n        // Sometimes the id comes as a number (e.g. when read from a Record in useGetList response).\n        // As the react-query cache is type-sensitive, we always stringify the identifier to get a match\n        queryKey: [resource, 'getOne', { id: String(id), meta }],\n        queryFn: queryParams =>\n            dataProvider\n                .getOne<RecordType>(resource, {\n                    id,\n                    meta,\n                    signal:\n                        dataProvider.supportAbortSignal === true\n                            ? queryParams.signal\n                            : undefined,\n                })\n                .then(({ data }) => data),\n        ...queryOptions,\n    });\n\n    useEffect(() => {\n        if (\n            result.data === undefined ||\n            result.error != null ||\n            result.isFetching\n        )\n            return;\n        onSuccessEvent(result.data);\n    }, [onSuccessEvent, result.data, result.error, result.isFetching]);\n\n    useEffect(() => {\n        if (result.error == null || result.isFetching) return;\n        onErrorEvent(result.error);\n    }, [onErrorEvent, result.error, result.isFetching]);\n\n    useEffect(() => {\n        if (result.status === 'pending' || result.isFetching) return;\n        onSettledEvent(result.data, result.error);\n    }, [\n        onSettledEvent,\n        result.data,\n        result.error,\n        result.status,\n        result.isFetching,\n    ]);\n\n    return result;\n};\n\nconst noop = () => undefined;\n\nexport type UseGetOneOptions<RecordType extends RaRecord = any> = Omit<\n    UseQueryOptions<GetOneResult<RecordType>['data']>,\n    'queryKey' | 'queryFn'\n> & {\n    onSuccess?: (data: GetOneResult<RecordType>['data']) => void;\n    onError?: (error: Error) => void;\n    onSettled?: (\n        data?: GetOneResult<RecordType>['data'],\n        error?: Error | null\n    ) => void;\n};\n\nexport type UseGetOneHookValue<RecordType extends RaRecord = any> =\n    UseQueryResult<GetOneResult<RecordType>['data']>;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}